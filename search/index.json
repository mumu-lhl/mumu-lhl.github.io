[{"content":"之前看见一名推友说自己用 AI 结对写小说，发表到番茄小说上，遇到了没有流量的问题，番茄小说的一些规则其实它都写了，但要细品，不然怎么让你在上面发小说呢？\n这里我就来梳理一下番茄小说写作的一些规则，可能都是我比较在意的。\n签约条件 年龄要求如下：\n16 岁以下不能签约 16-18 岁需要监护人的身份证和手机号码 18 岁以上不用说 为什么小说发表没有流量：推荐要求 番茄必须要签约后才会对小说进行推荐，在签约前想要有流量，只能自己想办法引流。\n你有继续发小说吗？ 没有了，我被挡在了签约条件第二条，发表的小说在签约前没有流量，我不知道值不值得签约，要是签约后不通过或是流量很差，我也没脸啊！会很后悔的！\n审核严格吗？ 审核似乎不是编辑在审，过不过审跟作品质量无关。审核速度非常快，快的话几分钟就过了（可怜勤勤恳恳的审核员\u0026hellip;）。\n能用 AI 写小说吗？ 番茄官方的作家助手 app 里是有 AI 助写的功能的，使用有限制，也应该是番茄的一种态度吧，大概能用，但是不要全用 AI 给写完了，即使过了审，如果被编辑或读者看出了，那就不好说会怎么样了。\n结尾 这篇文章很短，我猜你点了进来，可能对你有帮助吧。后续是我准备试试知乎的盐选小说的水，看了下规则，好像审核非常严，是编辑在审稿，每次投稿都会多次审核，不知道写出来能不能。但是现在，我得马上赶作业了\u0026hellip;\n","date":"2025-06-09T11:50:11.331Z","permalink":"https://mumulhl.eu.org/p/%E7%95%AA%E8%8C%84%E5%B0%8F%E8%AF%B4%E5%86%99%E4%BD%9C%E8%AF%95%E6%B0%B4/","title":"番茄小说写作试水"},{"content":"很久很久之前写了一篇在 Linux 上如何把 Android 作为麦克风的教程，不久前因为要用 Windows 上的一些软件，装上了 Windows，顺便折腾个在 Windows 上的把 Android作为麦克风的方案。\n找了很久，没有找到既方便又开源的方案，一些免费的方案（如 WO Mic）音质不太行，自己摸索了一方，最后用 Scrcpy 和 VB-CABLE 实现了。关键是 不需要在 Android 上安装任何软件！\n使用 Scrcpy 把 Android 作为麦克风理论上在 Linux 和 macOS 上也可以，在音频驱动那里会有点不同。\n确保 Android 版本 \u0026gt;= 11\n安装 Scrcpy 首先是 Scrcpy，它将用于从 Android 转发音频，可以在 Github Release 页面 下载对应的压缩包再解压，32 位下载 scrcpy-win32-vX.X.zip，64 位下载 scrcpy-win64-vX.X.zip。\n最好的办法是直接通过 Windows 的包管理器 winget 安装：\n1 winget install --id=Genymobile.scrcpy VB-CABLE VB-CABLE 的用途是将音频由输出转到输入。\n前往 VB-CABLE官网，点击 VBCABLE_Driver_Pack45.zip 下载压缩包，解压后，双击执行 VBCABLE_Setup_x64.exe（64 位）或 VBCABLE_Setup.exe（32 位）安装。然后就好了很么都不用动。系统 \u0026gt; 声音 \u0026gt; 输入 应该会自己变成 CABLE Output。\n正式步骤 Android 上开启 USB 调试 具体步骤见 Android Developer 文档。\n运行 Scrcpy 命令 如果通过压缩包获取 Scrcpy 点击解压后目录里的 open_a_terminal_here.bat 在该目录下打开终端。通过 winget 安装 Scrcpy 直接打开终端即可。\n接着运行：\n1 scrcpy --no-video --no-control --audio-source=mic-unprocessed 第一次运行 Android 上会要求授权，授权即可。\n参数解释：\n--no-video 不要画面 --no-control 不要控制 --audio-source=mic-unprocessed 将声音源指定为未处理的麦克风音频 声音源还有很多选项，完整选项见 Audio 文档，我觉得 mic-unprocessed 音质是最好的，也可以试试别的，简单列举几个：\nmic: 捕获麦克风 mic-unprocessed: 捕获未处理（原始）的麦克风声音 mic-camcorder: 捕获为录制视频调优的麦克风声音，如果可用，其方向与摄像头相同 mic-voice-recognition: 捕获为语音识别调优的麦克风声音 mic-voice-communication: 捕获为语音通信调优的麦克风声音（例如，如果可用，它会利用回声消除或自动增益控制） 改变音谱输出设备 在 系统 \u0026gt; 声音 \u0026gt; 音量合成器 \u0026gt; 应用 将 Scrcpy 创建的窗口的 输出设备 更改为 CABLE Input，现在通过 Android 麦克风输入的音频就不会从扬声器里输出了，会从输入设备 CABLE Output 里输出。\n","date":"2025-04-30T14:31:56.036Z","permalink":"https://mumulhl.eu.org/p/%E6%B2%A1%E9%BA%A6%E6%80%8E%E4%B9%88%E5%8A%9E%E6%8A%8A%E6%89%8B%E6%9C%BA%E5%BD%93%E4%BD%9C%E9%BA%A6%E5%85%8B%E9%A3%8Escrcpy-%E7%AF%87/","title":"没麦怎么办，把手机当作麦克风！（Scrcpy 篇）"},{"content":"Imagen 3 Imagen 3 是 Google DeepMind 最新的文生图模型，可以在 ImageFx 免费使用。Imagen 3 在 Gemini 内也是可以使用的，Gemini 生成图片有时会不听话，不生成图片，所以本文采用 ImageFx。\n如何实现人物一致性？ 主要有两种方式：\n对现有的人物图像进行“引用”，如 Midjourney 对人物描述相当详细的 Prompt，基本适用于各种文生图模型 第一种方式 Imagen 3 不支持，本文就采用第二种。\n创造人物形象 想要有一个对人物描述相当详细的 Prompt，由人来写就太繁琐了，可以提供一些人物的特征让大语言模型帮我们写，这里采用 Gemini 2.0 Flash Thinking 模型。给出的特征越详细越能生成符合自己想要的人物。\n示范 Prompt：\n1 2 3 4 5 6 7 8 9 10 11 12 13 你是一名文生图prompt专家，请写一个英文prompt去生成一个人物，将prompt放入代码块中。 prompt要求： 1. 无背景 2. 全身图 人物： 1. 白色头发 2. 穿白里带红的和服 3. 20岁左右的女性 4. 日本动漫风格 注：不要想着生成loli什么的，生成图片时会被判定为“儿童”而无法生成！\n先用大语言模型写的 Prompt 生成一下，如果效果不错，把种子锁定下，最好把种子保存下，方便以后生成尽可能相似的人物。\n根据人物创造详细的 Prompt 下载一张图片，发给支持图像的大语言模型，并让它根据图像创造出详细的 Prompt。\n示范 Prompt：\n1 你是一名文生图prompt专家，请写一个英文prompt去描述图像人物，将prompt放入代码块中。 把人物嵌入图像中 首先先生成一个生成人物坐在桌前写作业的图片的Prompt。\n示范 Prompt：\n1 2 3 4 5 6 7 你是一名文生图prompt专家，请写一个英文prompt去生成一张图片，将prompt放入代码块中。 要求： 1. 用 [CHARACTER] 代替人物 2. 人物坐在一张桌子前写作业 3. 氛围温馨 我们将使用 [CHARACTER] 代指人物，然后把上一个步骤生成的 Prompt 拼接进去，如：\n1 2 3 [CHARACTER] sitting at a wooden desk, writing homework in a softly lit room, warm atmosphere, cozy, desk lamp, books, study, home, peaceful, detailed, realistic. [CHARACTER]: 1girl, full body, Tomoe Gozen, white hair, long hair, white kimono, red and gold floral pattern, standing, arms outstretched, black background 最终效果图：\n","date":"2025-02-16T03:08:28.183Z","image":"https://mumulhl.eu.org/p/imagen-3-tutorial/cover_hu_b3cc5de7e23b498e.webp","permalink":"https://mumulhl.eu.org/p/imagen-3-tutorial/","title":"Imagen 3: 免费文生图工具保持人物一致性"},{"content":"（封面来自 Unsplash，作者 BoliviaInteligente）\n2024年结束了，2025年来了，转眼又是一年了。2024给我最大的震撼就是AI的辅助带来的便捷，过去稍有接触AI，但是没有太深入地使用，导致也用不好。\n真正对 AI 的接触 看到 X 上有很多大佬用 Cursor 开发出了一些项目，就有点手痒痒了。过去我使用的编辑器是 Helix，一个全键盘编辑器，感觉效率会高一些。如果要用 Cursor 这样的 AI 编辑器就要脱离全键盘的操作了，但是 AI 能提高我的开发效率的话，没有了全键盘操作也不算亏。于是 Cursor 就取代 Helix 在我的电脑上的地位。\nCursor 让我震撼的是，在编辑一块代码的时候，居然可以按 Tab 键去补全其他部分相关的代码，以前我以为 AI 代码补全就只能像补全变量名、函数名那样补全，这完全打破了我的认知啊！\n最早使用 AI 我都倾向于想用一句话让 AI 完成我想要做的有点复杂的事，但在理论上是不可行的，事实上也是不行的。只用一句话去表述一件较为复杂的事，信息量很少，难以去描述细节，AI 自然无法做到和自己所想的相符。和人说件事，说话只说一句，得让对方多疯狂，更别说是 AI 了。在我的使用体验来说，AI 更适合去做小任务，而非是复杂的大任务，如果要让 AI 去做大任务，将它分解为多个小任务效果会更好。\nAI 的使用体验总结起来就是一个字——“爽”，每周最多一天的时间里我可以开发得更高效。\n开源让我学到了很多 2024年新开发的项目主要实在暑假里开发的，好几个我都觉得不太行，所以只挑出我最经常维护的词悦来说吧。\n词悦是一个开源的支持 mdict 格式的词典，是我觉得 Android 上没有简洁、好用的开源的 mdict 词典而开发的。虽然最初发布的时候很简陋，不过现在经过几个月的开发，已经完善了许多了。\n最初词悦用 git-cliff 生成版本发布时的更新日志，后来我才慢慢在词悦中把 Github 的 label、milestones 功能好好用上，现在词悦的版本更新日志是由 Github 生成的，这样可以把这个版本贡献者直接显示在更新日志中。\n词悦还提交到了 F-Droid 上，我还提交过几个 MR，但是水平不太够，没办法，犯了很多低级错误，都由 linsui 大佬纠正了，感谢 linsui 大佬不知疲倦地修改我的 MR！\n在开源中，我学会了许多以前不知道的技巧、技术，开源不仅利他，还能利己。\n重启博客 2024，我重启了我的博客，一年的文章就是2023的十几倍了（2023只有一篇文章）。2024我写了15篇博文，其中大部分都是在暑假写的。暑假闲来无事重启了博客，还把博客主题换成了 Stack。我还把博客提交到 V2EX VXNA、博友圈等平台上，我的博客也终于不再是我自娱自乐的地方了。\n对2025的展望 希望我可以在2025把 AI 使用得更加得心应手吧；希望我能在2025凭借自己的能力去赚到人生第一桶金，哪怕没几块也行哪。\n","date":"2025-01-01T02:07:26.855Z","image":"https://mumulhl.eu.org/p/2024-year-in-review/2024_hu_10b9e79b07cefd32.jpg","permalink":"https://mumulhl.eu.org/p/2024-year-in-review/","title":"2024年度总结：AI原来能这么好用"},{"content":"最近在开发词悦（一个 mdict 词典）的时候，需要支持全局上下文菜单，查了很多资料都没有找到合适的方法，问了下 cursor，得到了初步方案，经过稍微的改动就有了这篇教程。\n本文开发环境在 Linux 下。\n初始化项目 1 2 flutter create example cd example 写代码 Manifest 编辑 android/app/src/main/AndroidManifest.xml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- 省略... --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;io.flutter.embedding.android.NormalTheme\u0026#34; android:resource=\u0026#34;@style/NormalTheme\u0026#34; /\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;!-- 新增的部分 --\u0026gt; \u0026lt;!-- android:label 是上下文菜单中显示的名称 --\u0026gt; \u0026lt;activity android:name=\u0026#34;.ProcessTextActivity\u0026#34; android:label=\u0026#34;example\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.PROCESS_TEXT\u0026#34; /\u0026gt; \u0026lt;data android:mimeType=\u0026#34;text/plain\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; 原生 Android 创建 android/app/src/main/kotlin/com/example/example/ProcessTextActivity.kt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.example import android.app.Activity import android.content.Intent import android.os.Bundle import io.flutter.embedding.android.FlutterActivity class ProcessTextActivity : Activity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val text = intent?.getCharSequenceExtra(Intent.EXTRA_PROCESS_TEXT)?.toString() ?: \u0026#34;\u0026#34; val intent = Intent(this, MainActivity::class.java).apply { action = Intent.ACTION_PROCESS_TEXT putExtra(Intent.EXTRA_PROCESS_TEXT, text) addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK) // 如果不加这个 flag，app 在后台运行时无法把选中的文本传给 Flutter } startActivity(intent) finish() } } 编辑 android/app/src/main/kotlin/com/example/example/MainActivity.kt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.example import android.content.Intent import android.os.Bundle import io.flutter.embedding.android.FlutterActivity import io.flutter.embedding.engine.FlutterEngine import io.flutter.plugin.common.MethodChannel class MainActivity: FlutterActivity() { private val CHANNEL = \u0026#34;com.example.example/process_text\u0026#34; private var methodChannel: MethodChannel? = null override fun configureFlutterEngine(flutterEngine: FlutterEngine) { super.configureFlutterEngine(flutterEngine) methodChannel = MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) if (intent?.action == Intent.ACTION_PROCESS_TEXT) { val text = intent.getCharSequenceExtra(Intent.EXTRA_PROCESS_TEXT)?.toString() ?: \u0026#34;\u0026#34; methodChannel?.invokeMethod(\u0026#34;processText\u0026#34;, text) } } } Flutter 部分 编辑 lib/main.dart:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:flutter/services.dart\u0026#39;; void main() { WidgetsFlutterBinding.ensureInitialized(); platform.setMethodCallHandler((call) async { if (call.method == \u0026#34;processText\u0026#34;) { final text = call.arguments as String; // call.arguments 里就是选中的文本了 print(text); } }); runApp(const MyApp()); } const platform = MethodChannel(\u0026#34;com.example.example/process_text\u0026#34;); 结尾 接下来怎么样就靠你的想象力了 :)\n","date":"2024-11-30T15:16:10.308Z","permalink":"https://mumulhl.eu.org/p/%E7%BB%99flutter-android-app%E6%94%AF%E6%8C%81%E5%85%A8%E5%B1%80%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95/","title":"给Flutter Android App支持全局上下文菜单"},{"content":"当我们像在仅需要在局域网内进行直播这种情况时，就可以自己动手搭建极简的直播服务。\n预备知识 会写一点点 nginx 配置。\n概念 RTMP 用于流媒体传输的协议，最初用于 Flash 播放器，也可以用于直播。\n本教程中，我们将用该协议将直播流推送至 nginx 服务器。\nHLS 基于 HTTP 流媒体传输协议，它将流分割成多个文件传输，对于直播流，以 m3u8 文件为播放列表，以 ts 文件为视频。\n本教程中，该协议用于向浏览器传输直播流。\n编译 nginx nginx 本身并不支持 RTMP 协议，需要把 nginx-rtmp-module 模块编译进 nginx。\n从 nginx.org 下载 nginx 源码，解压后进入目录。\n然后克隆 nginx-rtmp-module 源码：\n1 git clone https://github.com/arut/nginx-rtmp-module --depth=1 编译并安装 nginx：\n1 2 3 ./configure --add-module=nginx-rtmp-module make make install 最后 /usr/local/nginx/sbin 添加到环境变量 PATH 中。\n前端 一般浏览器不能直接播放 HLS，这里采用 DPlayer + hls.js 用于播放 （因为好看）。\n从 这里 还有 这里 下载 DPlayer.min.js 和 hls.min.js 到 /usr/local/nginx/html/。\n将 /usr/local/nginx/html/index.html 改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;直播\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;dplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;hls.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;DPlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const dp = new DPlayer({ container: document.getElementById(\u0026#39;dplayer\u0026#39;), autoplay: true, // 自动播放 live: true, // 直播 video: { url: \u0026#39;/live/example.m3u8\u0026#39;, // 等下 example 改成自己的推流码 type: \u0026#39;hls\u0026#39;, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打开首页就是播放器。\n配置 将 /usr/local/nginx/html/conf/nginx.conf 改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 worker_processes 1; events { worker_connections 1024; } rtmp { server { listen 1935; chunk_size 4000; application live { # /live 是推流地址 live on; hls on; hls_path html/live; } } } http { server { listen 8080; location / { root html; add_header Cache-Control no-cache; } } } 关于 nginx-rtmp-module 更多配置见 wiki。\n不用担心 HLS 的 ts 文件会无限增加下去，nginx-rtmp-module 会删除老的 ts 文件。\n启动 nginx：\n1 nginx 推流 这里推流使用 OBS Studio。\n在“设置”-“直播”中填写“服务器”为 http://localhost:8080/live，“推流码”填自己想要的，但 index.html 中的 example 要改成这个推流码，不然没法播放直播。\n配置好来源就可以开始直播啦~\n试试看 打开 http://localhost:8080 就可以看到直播了，大概会有 10s 左右的延迟。\n正式使用时，请根据自己的需求更改。\n结语 过去，学校里的大型表演，能到现场看的人数有限，不是所有人都能到现场看，而且没有直播。再过不久有一个歌唱比赛（我当然去参加海选了，只不过没选上），我想搭建一个直播服务去直播这些表演，于是就有了这篇教程。因为能否直播还要征得校方同意，所以不一定能用得上\u0026hellip;\n","date":"2024-09-30T20:31:22+08:00","permalink":"https://mumulhl.eu.org/p/nginx-live-service/","title":"nginx 搭建极简直播服务"},{"content":"介绍 Material You 加入到 Android 12 中，其中包括了动态配色。\n用户可以直接在系统层面上很方便地改变系统配色和支持动态配色的软件的配色。开发者也不需要再开发配色功能。\n设置 （因为不同厂商把选项名改得不一样，所以很难明确写出选项的名称）\n打开设置 点击一个名称大致包含了 桌面、壁纸 的选项 点击名称像 系统风格 的选项，就可以选择颜色了。 可以单独选择配色，也可以从壁纸上提取出颜色。\n结语 用了 Android 13 一整年了，都不知道有这个功能 😂 最近用 Flutter 开发词典的时候才了解到。\n","date":"2024-08-15T15:25:12+08:00","permalink":"https://mumulhl.eu.org/p/android-dynamic-color-tutorial/","title":"给 Android 换个配色"},{"content":"你的电脑可能没有麦克风，需要的时候，又不想买一个麦克风，这时候就可以把你的 Android 当作麦克风来用。\nAudio Source 是一个用 ADB 将 Android 麦克风的输入转发到 PulseAudio 进程的工具。\n准备 一只手 Android 4.0 及以上 一条 USB 数据线，充电线也没问题 PATH 中包含 python3、pactl、adb（Archlinux 如果没有 adb，用 sudo pacman -S android-tools 安装，安装后需重启） 使用 Android 端 可在 Releases 页面下载，或在 IzzyOnDroid F-Droid Repository 下载。\n安装后，点开软件，如果没看到 UI 很正常，这个软件就是没有 UI 的\u0026hellip; 然后要授权软件麦克风和通知权限，如果授权权限的弹窗闪退，可以在 设置 里面授权软件权限。\nLinux 端 下载 audiosource 脚本并授权可执行权限。\n1 curl -O https://raw.githubusercontent.com/gdzx/audiosource/master/audiosource \u0026amp;\u0026amp; chmod +x audiosource 用 USB 数据线连接手机和电脑，在 开发者选项 里开启 USB 调试模式。\n用 adb 查看一下连接的 Android 设备，这时手机会弹出授权窗口，点授权就完事了。授权完再运行一下这个命令，看看是否正常。\n1 adb devices 运行 audiosource 脚本，你的 Linux 就有麦克风啦 :)\n1 ./audiosource run 结语 Audio Source 是我意外在 F-Droid 找到的，F-Droid 上的宝藏很多 :)\n","date":"2024-08-11T12:40:00+08:00","permalink":"https://mumulhl.eu.org/p/audio-android-to-linux/","title":"将 Android 作为 Linux 的麦克风"},{"content":"yt-dlp 是一个功能强大的命令行音频、视频下载器。yt-dlp fork 自基于 youtube-dl 的已不维护的 youtube-dlc，具有额外的功能和问题修复。\nyt-dlp 不仅支持 YouTube，还支持一千多个网站。除了下载音频、视频，还能下载封面。\n安装 可以通过 pip 安装，也可以通过你所用的系统的包管理器安装，还可以到 release 页面下载可执行文件。\n1 2 3 pip install yt-dlp # or pipx install yt-dlp 使用 视频 直接加链接即可。\n1 yt-dlp \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 可以下载一整个播放列表的视频。\n1 yt-dlp \u0026#34;https://www.youtube.com/playlist?list=PLp8YAQVH95dwCMvzkxUhFy4KWRAtp_awf\u0026#34; 还可以下载 m3u8。\n1 yt-dlp \u0026#34;https://example.com/index.m3u8\u0026#34; 列出视频可以下载的格式，也列出了传输协议、格式、分辨率、帧率、大小等信息。\n1 2 3 yt-dlp -F \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; # 与下面的命令等价 yt-dlp --list-formats \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; yt-dlp 默认会下载分辨率、帧率等最好的视频，如果要指定相应的分辨率、帧率，要用 --format-sort/-S 参数。\n下载分辨率不优于 720p 的视频，也就是下载 720p 的视频。\n1 yt-dlp -S \u0026#34;res:720\u0026#34; \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 指定视频的容器格式。\n1 yt-dlp -S \u0026#34;ext:webm\u0026#34; \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 用 , 连接多个限制条件。\n1 yt-dlp -S \u0026#34;ext:webm,res:720\u0026#34; \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 嵌入元数据，默认不嵌入。\n1 yt-dlp --embed-metadata \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 嵌入封面，默认不嵌入。\n1 yt-dlp --embed-thumbnail \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 嵌入字幕，默认不嵌入。仅支持 mp4、mkv、webm 容器的视频\n1 yt-dlp --embed-subs \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 音频 分离出视频中的音频。\n1 2 3 yt-dlp -x \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; # 与下面的命令等价 yt-dlp --extract-audio \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 指定音频的格式和品质，品质取值 0-10，0 最佳，10 最差，默认为 5。\n1 yt-dlp -x --audio-format opus --audio-quality 0 \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 嵌入元数据。\n1 yt-dlp -x --embed-metadata \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 封面 列出所有封面。\n1 yt-dlp --list-thumbnails \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 下载封面，同时会下载视频。\n1 yt-dlp --write-thumbnail \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 下载所有封面，不会下载视频。\n1 yt-dlp --write-all-thumbnails \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 结语 写不出什么结语了(liao) :(\n","date":"2024-08-10T20:59:35+08:00","permalink":"https://mumulhl.eu.org/p/yt-dlp-tutorial/","title":"yt-dlp 教程"},{"content":"Dict_reader 是一个用于读取 mdict 词典的 Dart 语言库，支持 MDX/MDD 格式。\nREADME 提供了几个示例，本文提供更适合生产环境的示例。\n安装 1 dart pub add dict_reader 使用 在生产环境中，会用到搜索单词、查看单词的功能，而且必须要高效，这时候轮到 SQLite 数据库出场了。在第一次读取词典时，用 Drift 存储少量数据，用于之后快速地搜索和查看。\n安装 Drift 1 dart pub add drift drift_flutter dev:drift_dev dev:build_runner 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // database.dart import \u0026#34;package:dict_reader/dict_reader.dart\u0026#34;; import \u0026#34;package:drift/drift.dart\u0026#34;; import \u0026#34;package:drift/native.dart\u0026#34;; import \u0026#34;dart:io\u0026#34;; part \u0026#39;database.g.dart\u0026#39;; @TableIndex(name: \u0026#39;idx_keyText\u0026#39;, columns: {#keyText}) class Dictionary extends Table { TextColumn get keyText =\u0026gt; text()(); IntColumn get recordBlockOffset =\u0026gt; integer()(); IntColumn get startOffset =\u0026gt; integer()(); IntColumn get endOffset =\u0026gt; integer()(); IntColumn get compressedSize =\u0026gt; integer()(); } @DriftDatabase(tables: [Dictionary]) class AppDatabase extends _$AppDatabase { // After generating code, this class needs to define a `schemaVersion` getter // and a constructor telling drift where the database should be stored. // These are described in the getting started guide: https://drift.simonbinder.eu/getting-started/#open AppDatabase() : super(_openConnection()); @override int get schemaVersion =\u0026gt; 1; Future\u0026lt;void\u0026gt; insertUsers(List\u0026lt;DictionaryCompanion\u0026gt; dictionary) async { await batch((batch) { batch.insertAll(this.dictionary, dictionary); }); } Future\u0026lt;List\u0026lt;DictionaryData\u0026gt;\u0026gt; searchWord(String word) { return (select(dictionary)..where((u) =\u0026gt; u.keyText.like(\u0026#39;$word%\u0026#39;))).get(); } static QueryExecutor _openConnection() { return NativeDatabase(File(\u0026#39;dictionary.db\u0026#39;)); } } void main() async { final database = AppDatabase(); final dictReader = DictReader(\u0026#34;MDX FILE PATH\u0026#34;); // 不用获取 keyText 和 offset 存入数据库时，可以传入 false 参数 await dictReader.init(); // 将 keyText 和 offset 存入数据库，只需一次 var queue = \u0026lt;DictionaryCompanion\u0026gt;[]; await for (final ( keyText, (recordBlockOffset, startOffset, endOffset, compressedSize) ) in dictReader.read()) { queue.add(DictionaryCompanion( keyText: Value(keyText), recordBlockOffset: Value(recordBlockOffset), startOffset: Value(startOffset), endOffset: Value(endOffset), compressedSize: Value(compressedSize))); } await database.insertUsers(queue); // 通过数据库搜索单词 final result = (await database.searchWord(\u0026#34;go\u0026#34;))[0]; // 获取单词数据 print(await dictReader.readOne(result.recordBlockOffset, result.startOffset, result.endOffset, result.compressedSize)); await database.close(); } 然后生成 database.g.dart 文件：\n1 dart run build_runner build 这个示例不适合直接放到生产环境中，稍微改一下就可以了。\n结语 Dict_reader 主要是翻译 mdict-analysis。我对 Dart 不是很熟，在翻译过程中经常去问 gpt-4o-mini 以及 SearchGPTool，有帮助也有捣乱，最终还是花了四天时间完成。\nDict_reader 并没有完全翻译，而且挑选了最重要、有意义的部分翻译，也基于我自身考虑（我手头没有 mdict 格式 3.0 版本的词库），例如没有校验、不支持 lzo 压缩、不支持 mdict 格式的 3.0 版本，但不影响一般使用。\n","date":"2024-08-09T17:56:10+08:00","permalink":"https://mumulhl.eu.org/p/dict-reader-tutorial/","title":"Dart 中读取 mdict 词典教程"},{"content":"最近趁着暑假学钢琴，但家里没有钢琴，于是舅舅送了我一台电子琴。\n这台电子琴型号是 MK-2089，61 键，255 种音色，255 种伴奏，24 首示范曲。\n小故事 1 收到的这台电子琴有两个白键翘起来，按照 B 站上的教程，拧了十几个螺丝放回去，又拧了十几个螺丝装好，还有两个拧不回去了，而且手都快拧成麻花了，肯定很香。\n2 看了电子琴架拼装示范图半天，都不知道怎么装电子琴架，毕竟我连劳动课上简单的小东西看说明书也做不出来。最后我对着孔的间距装好了，然后我发现电子琴可以直接放桌子上，把椅子升高一下就能弹了\u0026hellip;\n图片 评测 这些仅是我个人的看法，我不是专业的。\n优点：\n耳机看上去很高级，因为没有其他耳机，无法比较 修起来方便 有麦克风，改天我可以去做主播了（试了一下，插在电脑上没什么用） 缺点：\n音色听上去一般般 没有 MIDI 接口 没有触感检测，也就是弹出来的音没有轻重 示范曲听起来明显是一个人写的 ","date":"2024-08-05T21:23:30+08:00","permalink":"https://mumulhl.eu.org/p/new-electronic-keyboard/","title":"上手美科2089电子琴"},{"content":"dig 是用来查询 DNS 的工具，doggo 则是它现代的增强品。\n有个叫作 dog 的 dig 替代品，但是已经多年没更新了，doggo 的灵感就是来自 dog。写这篇文章时，doggo 依然保持更新。\ndoggo 不仅是一个命令行工具，还有个网页版。\n特点 采用彩色编码和表格格式的人类可读输出 支持 JSON 输出，便于脚本编写和解析 多种传输协议： DoH、DoT、DoQ、TCP、UDP、DNSCrypt 支持 ndots 和 search 配置 支持多个解析器，可自定义查询策略 支持 IPv4 和 IPv6 提供网络接口 提供 zsh 和 fish 的补全 反向 DNS 查询 灵活的查询选项，包括各种 DNS 标志 用于故障排除的调试模式 响应时间测量 支持跨平台 安装 脚本 1 curl -sS https://raw.githubusercontent.com/mr-karan/doggo/main/install.sh | sh 包管理 Homebrew: brew install doggo Arch Linux: yay -S doggo-bin Scoop (Windows): scoop install doggo Eget: eget mr-karan/doggo 二进制文件 https://github.com/mr-karan/doggo/releases\nGo Install 1 go install github.com/mr-karan/doggo/cmd/doggo@latest 快速上手 不想打五个字的话，可以 alias dig=\u0026quot;doggo\u0026quot;，把 dig 设置为 doggo 的别名，这样就只用打三个字了。\n1 2 3 4 5 doggo example.com # 查询 A 记录 doggo example.com AAAA # 查询 AAAA 记录 doggo example.com A NS # 查询多个记录 输出结果非常简洁，而且带有颜色。\n结语 文本所介绍的内容已经可以满足大部分需求了，想要更深入使用，可以观光下文档 https://doggo.mrkaran.dev/docs/。\n","date":"2024-08-04T15:36:46+08:00","permalink":"https://mumulhl.eu.org/p/doggo-tutorial/","title":"dig 的现代替代品 doggo"},{"content":"Duckduckgo AI Chat 提供了免费的 gpt-4o-mini，我开发了一个小库 duckduckgo-ai-chat 用来调用 Duckduckgo AI Chat 的 API。\n注意事项 Duckduckgo AI Chat 是有针对 IP 的额度限制的，不要滥用。\n小故事 在 jsr.io 上的 duckduckgo-ai-chat 之所以第一个版本是 2.0.0，是因为 1.0.0 基于 Bun 编写发布在 npm 上，发完才发现 bun 不符合我的 all-in-one 需求，所以就换 Deno 了\u0026hellip;\n顺便发到了 Deno 团队新搞的 jsr.io 上，不仅支持用不同包管理器安装，而且还支持在任何运行时上跑。\n兼容性 除了 Bun，其他运行时都没问题。\n安装 1 2 3 4 5 6 7 npx jsr add @mumulhl/duckduckgo-ai-chat # or pnpm dlx jsr add @mumulhl/duckduckgo-ai-chat # or yarn dlx jsr add @mumulhl/duckduckgo-ai-chat # or deno add @mumulhl/duckduckgo-ai-chat 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { initChat } from \u0026#34;@mumulhl/duckduckgo-ai-chat\u0026#34;; // 初始化，可选模型有 gpt-4o-mini, claude-3-haiku-20240307, meta-llama/Llama-3-70b-chat-hf, mistralai/Mixtral-8x7B-Instruct-v0.1 const chat = await initChat(\u0026#34;gpt-4o-mini\u0026#34;); // 一次性获取完整的回复 let message = await chat.fetchFull(\u0026#34;Hello\u0026#34;); console.log(message) // 重新回复 chat.redo() message = await chat.fetchFull(\u0026#34;Hello\u0026#34;); console.log(message) // 获取流式回复 const stream = chat.fetchStream(\u0026#34;Hello\u0026#34;); for await (let data of stream) { console.log(data) } ","date":"2024-08-01T16:12:35+08:00","permalink":"https://mumulhl.eu.org/p/duckduckgo-ai-chat-api/","title":"JavaScript/TypeScript 免费调用 gpt-4o-mini"},{"content":"Simple Friend Circle 是我偶然想到的一个超简单的友链朋友圈，它不需要后端，只需要 CI 去定时拉取博文，然后生成静态页面，再在自己的博客上用 \u0026lt;iframe\u0026gt; 引入这个静态页面。\n搭建 Fork 这个项目，在 Actions 中开启 workflows，然后开启叫作 Friend Circle 的 workflow，关闭叫作 Lint Commit Messages 的 workflow，之后在 Settings 的 Pages 中将 Branch 选为 gh-pages。\n（是不是很简单？:)）\n配置 links 文件用于配置各个博客的 RSS 链接和头像，像这样：\n1 https://mumulhl.eu.org/index.xml https://mumulhl.eu.org/img/avatar_hub440208ea63c4061633255bf6046ed7b_104338_300x0_resize_q75_h2_box_2.webp 插入博客 在想要插入友链朋友圈的网页加入这段 HTML：\n1 \u0026lt;iframe src=\u0026#34;https://YOUR GITHUB NAME.github.io/simple-friend-circle/\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;600rem\u0026#34; style=\u0026#34;border:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 样式 像颜色之类的可以到 public/main.css 自行调整，默认的颜色来自我用的 Stack 主题。\n","date":"2024-07-30T11:41:16+08:00","permalink":"https://mumulhl.eu.org/p/simple-friend-circle-tutorial/","title":"简易友链朋友圈搭建教程"},{"content":"yt-music-archive 是我写的一个小脚本，用于将 Youtube Music 上的音乐下载到本地，并将其 ID 存入一个存档文件中，也可以从存档文件中还原出音乐。\n（我在花了几个小时写完后，才想起用 yt-dlp 下载播放列表也可以做到同样的功能，算了，写了都写了，就水写篇教程吧\u0026hellip;）\n安装 1 2 3 git clone https://github.com/mumu-lhl/yt-music-archive cd yt-music-archive sudo make 或者从 AUR 安装：\n1 2 3 yay -S yt-music-archive # or paru -S yt-music-archive 使用 1 2 3 4 5 6 yt-music-archive save \u0026lt;ID\u0026gt; # 下载音乐并将 ID 存入存档文件，默认音乐保存在 ~/Music yt-music-archive save \u0026lt;ID\u0026gt; -p \u0026lt;PATH\u0026gt; # 指定音乐保存到哪个路径下 yt-music-archive fetch # 根据存档的 ID 拉取音乐，默认音乐保存在 ~/Music yt-music-archive fetch -p \u0026lt;PATH\u0026gt; # 指定音乐保存到哪个路径下 配置 目前可配置的选项不多，可以编辑 /etc/yt-music-archive/yt-music-archive.conf 或 ~/.config/yt-music-archive/yt-music-archive.conf：\n1 2 3 archive_file=~/.local/share/yt-music-archive/archive # 存储 id 的存档文件 #default_path=~/Music # 默认保存音乐的路径 结语 I\u0026rsquo;m a 🤡.\n","date":"2024-07-27T22:02:28+08:00","permalink":"https://mumulhl.eu.org/p/yt-music-archive-tutorial/","title":"存档 Youtube Music ID 批量下载音乐"},{"content":"概念 PKGBUILD PKGBUILD 文件采用 Bash 语法，用于 Archlinux 及其衍生发行版构建软件包，用户可以将自己编写的 PKGBUILD 发布到 AUR(Arch User Repository)，让其他用户构建并安装软件包（通常由工具完成，如 yay、paru）。\n编写 PKGBUILD 只需要 Bash 的 创建变量、读取变量、声明函数、创建数组 等少量知识即可，可以到 网道 WangDoc 学习。\nmakepkg 读取 PKGBUILD 构建软件包的工具。\n辅助工具 这些工具在后文会介绍具体，请先用 pacman 安装，可以简化 PKGBUILD 的维护：\ndevtools - 包含的 pkgctl nvchecker - 为 pkgctl 提供版本检测 namcap - 检测 PKGBUILD 常见的错误 updpkgsums - 自动下载软件来源，计算 hash 填入 PKGBUILD（不用另外安装） 1 sudo pacman -S devtools nvchecker namcap 这些工具你可能需要（不要的话关系也不大），使用自行看其文档：\ntermux-language-server - 为 PKGBUILD 提供语言服务器（Language Server） 基本格式 你可以在 /usr/share/pacman 目录下找到三个没有注释的 PKGBUILD 示例文件，其中 PKGBUILD.pro 应该是最有用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # https://wiki.archlinux.org/title/Arch_package_guidelines # Maintainer: Your Name \u0026lt;youremail@domain.com\u0026gt; pkgname=NAME # 名称 pkgver=VERSION # 版本 pkgrel=1 # 通常为 1，不需要更改，当版本不变需要让用户重新安装软件包时 #（如 PKGBUILD 增加补丁、修复 bug），需要加 1。 pkgdesc=\u0026#34;\u0026#34; # 介绍 arch=() # 适用的架构，如 x86_64、aarch64、i386，也可以是 any，表示软件不受架构限制 url=\u0026#34;\u0026#34; # 软件主页链接 license=(\u0026#34;GPL\u0026#34;) # 许可证 groups=() # 归属的软件包组，基本用不到 depends=() # 软件运行所需的依赖 makedepends=() # 构建软件所需的依赖 optdepends=(\u0026#34;package_name: description\u0026#34;) # 软件运行可选的依赖 provides=() # 提供的功能 conflicts=() # 与什么功能冲突，通常与 provides 的值相同 replaces=() # 该包安装时替换什么包，基本用不到 backup=() # 该包安装或卸载时，要备份的文件的路径， # 使用相对路径（如 etc/pacman.conf），通常是配置文件。 # 小知识： # 升级时包自带的要备份的文件将会以 .pacnew 后缀保存，不覆盖本地的； # 卸载时本地的要备份的文件会以 .pacsave 后缀重新命名 options=() # makepkg 选项，具体参数在 # https://man.archlinux.org/man/PKGBUILD.5#OPTIONS_AND_DIRECTIVES changelog= # 软件更新日志，基本都不写的 source=(FILENAME::URL) # 不定构架，软件来源（可以是压缩文件，也可以是 git 仓库地址，写法见下面的 git 示例）， # FILENAME 用于将下载到的文件命名为它， # 可以用上面定义的变量组成，如 $pkgname-$pkgver.tar.gz # makepkg 会自动解压，解压后的目录存于变量 srcdir # URL 则是指向文件的链接 #source=(URL) # FILENAME 也可以省略 #source_x86_64 # 相应架构的软件来源 noextract=() # 需要其他解压工具时，不解压的软件来源，填写这一项需要在 prepare 函数中解压文件 # 还要在 makedepends 填写解压工具 sha256sums=() # 不定架构的软件来源的 hash，下文将介绍用 updpkgsums 自动填写，也可以用其他的 hash，如 sha512 #sha256sums_x86_64 # 特定架构的软件来源的 hash # pkgver 函数用于获取软件版本，替代 pkgver 变量，通常用于打包直接用 git 拉取仓库进行构建的软件包 #pkgver() {} # prepare 函数准备软件构建，在 build 函数前执行 #prepare() {} # build 函数构建软件，在 package 函数前执行 #build() {} # package 函数安装软件 package() { # 安装二进制文件 # 工作步骤： # 1. 将一个文件复制到另一个文件 # 2. 赋予复制后的文件可执行权限 install -Dm755 ${srcdir}/binary ${pkgdir}/usr/bin/binary # srcdir 变量是软件来源解压后的目录 # pkgdir 变量是一个存放被打包的文件的目录 } 自动填写 hash 1 updpkgsums 示例 请根据自己要打包的软件选择示例，也可以直接跳到 如何发布。\n二进制 见 基本格式\ngit 从仓库拉取构建 只写出一些与打包二进制的不同的地方。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 pkgname=NAME-git # 名称应该以 -git 结尾 pkgver=1 # 先随便填个版本进去，等下构建时 makepkg 会自动填写 pkgver 函数生成的版本 sha256sums=(\u0026#34;SKIP\u0026#34;) # 因为拉取最新的仓库所以无法指定 hash，直接跳过检查 hash source=(\u0026#34;git+https://URL\u0026#34;) pkgver { # 从 git 仓库生成软件版本 # 其他实现见: https://wiki.archlinux.org/title/VCS_package_guidelines#Git cd \u0026#34;$pkgname\u0026#34; ( set -o pipefail git describe --long --abbrev=7 2\u0026gt;/dev/null | sed \u0026#39;s/\\([^-]*-g\\)/r\\1/;s/-/./g\u0026#39; || printf \u0026#34;r%s.%s\u0026#34; \u0026#34;$(git rev-list --count HEAD)\u0026#34; \u0026#34;$(git rev-parse --short=7 HEAD)\u0026#34; ) } 其他 如 pip、npm、cargo 等编程语言的软件包的打包是不需要手写 PKGBUILD 的，用脚本生成就可以了，见 Arch Wiki。\n测试 构建 写完 PKGBUILD 最好测试一下能否正常构建软件。\n1 makepkg 这是最简单的测试方法，但有个问题，因为安装了很多包，系统是不“干净”的，如果 PKGBUILD 中有依赖没写上去，也会正常构建，为了避免这种情况，可以用 pkgctl 构建。\n1 pkgctl build pkgctl 会自动在一个“干净”的 chroot 里下载安装依赖并构建软件。而且还会生成 .SRCINFO 文件，这是发布至 AUR 必须要有的文件。\n安装 1 makepkg --install 发布 如果测试没问题的话就可以发布了。首先的首先，你需要一个 AUR 账号，这个步骤很简单，就不写了。\n验证 创建 AUR 专用的 SSH 密钥。\n1 ssh-keygen -f ~/.ssh/aur 在 ~/.ssh/config 中加入这些内容：\n1 2 3 Host aur.archlinux.org IdentityFile ~/.ssh/aur User aur 最后在 AUR 账号的设置页面加入 ~/.ssh/aur.pub 里的公钥就好了。\n生成 .SRCINFO 文件 如果不是用 pkgctl 测试构建软件包，那么需要这条命令生成 .SRCINFO 文件：\n1 makepkg --printsrcinfo \u0026gt; .SRCINFO 创建包仓库 AUR 只接受 master 分支的推送。\n1 2 3 4 5 6 7 # 如果还没有 git 仓库 git -c init.defaultbranch=master clone ssh://aur@aur.archlinux.org/pkgbase.git # 如果已有 git 仓库 git switch -c master ## 如果有了提交 git branch -d 推送 这一步不用我多说吧 :)\n自动更新 根据 PKGBUILD 生成自动更新的配置 .nvchecker.toml：\n1 pkgctl version setup 更新 PKGBUILD 中的 pkgver：\n1 pkgctl version upgrade 再用 updpkgsums 自动填写 hash，非常的完美！\n日常维护 当你维护一大堆包的时候，显然一个个去更新太慢了。可以把所有包的仓库放在一个目录下，再在这个目录下执行这条命令一次性更新所有包：\n1 pkgctl version $(ls) 如果哪个包被更新了，要手动去构建一下，然后提交推送，避免出问题。这个任务不算很难，毕竟一下子也不会有很多包更新。\n结语 这篇文章写起来超费时间，比写三篇小短文的总时间还要多 :(\n因为找不到 PKGBUILD 编写、发布、自动更新一体化的教程，所以就自己写啰。\n这篇文章介绍编写的 PKGBUILD 比较简单，不是很完整，剩下就是下一篇文章的事了 :)\n","date":"2024-07-25T19:54:02+08:00","permalink":"https://mumulhl.eu.org/p/pkgbuild-tutorial/","title":"PKGBUILD 编写、发布、自动更新教程"},{"content":"本站所用的主题没有直接把 RSS 链接显示在网页上，而是放在了 HTML \u0026lt;link\u0026gt; 标签里，但是要怎么订阅本站的所有或部分文章呢？\nHowTo 如果要订阅本站所有文章，在 RSS 阅读器里直接订阅 https://mumulhl.eu.org。如果要根据标签、分类订阅，直接订阅相应的链接就可以了，如 https://mumulhl.eu.org/categories/skill/。\n（RSS 还能这样订阅以前都不知道，最近才意外知道）\n如何实现？ HTML \u0026lt;link\u0026gt; 最常见的用法就是为网页引入 CSS 文件，它的作用是标志网页和外部资源的关系。\n1 \u0026lt;link href=\u0026#34;main.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; href 属性的值是文件路径，rel 则是 relationship 的缩写，表示网页和外部资源的关系。rel 是 stylesheet，就表示 main.css 是该网页的 CSS。\n引入 RSS 的 \u0026lt;link\u0026gt; 是长这样的：\n1 \u0026lt;link href=\u0026#34;index.xml\u0026#34; rel=\u0026#34;alternate\u0026#34; type=\u0026#34;application/rss+xml\u0026#34;\u0026gt; type 的值为 application/rss+xml 标志了 index.xml 的类型是 RSS，rel 的值为 alternate 根据 MDN 意思是当前网页的替代。\nRSS 阅读器通常支持这种方式订阅，以前我只知道输入 RSS 文件的链接订阅\u0026hellip;\n","date":"2024-07-23T09:57:30+08:00","permalink":"https://mumulhl.eu.org/p/rss-for-my-website/","title":"用 RSS 订阅本站的所有文章或按标签、分类订阅文章"},{"content":"以后也会写像这样的工具类文章，写得特快\u0026hellip;不会写得很啰唆，简单利落。\nVermin Vermin 是一个检测 Python 代码所需的最低版本的工具，在本文写时已经有一段时间没有更新了。\n安装 1 2 3 4 5 6 7 8 9 10 # pip pip install vermin # pipx pipx install vermin # AUR yay -S python-vermin # or paru -S python-vermin 使用 1 2 # 检测目录下的所有 Python 代码，这条命令可以满足大部分需求，不需要怎样配置 vermin . ","date":"2024-07-22T14:56:53+08:00","permalink":"https://mumulhl.eu.org/p/detect-minimum-python-version/","title":"检测 Python 代码所需的最低版本"},{"content":"上次写博客还是在上次呸，上次写博客在一年前了\u0026hellip;\n概念 Scrobbler Scrobbler 的意思是是向音乐社区平台提交音乐播放记录的程序。\n音乐社区平台 音乐社区平台，往往不直接提供音乐，允许用户评论音乐，记录 Scrobbler 向其提交的 不同音乐播放器 上音乐播放记录，根据记录的数据推荐音乐， 总结听歌报告。\n选择音乐社区平台 Last.fm 是一个音乐社区平台用户量应该是最多的，部分功能收费。\nListenBrainz 是我目前正在使用的音乐社区平台，是开源项目，可以自行部署，完全免费。\n为了节省打字时间，还有一些可以自行部署的音乐社区平台就自行去找啦~\n选择 Scrobbler 搜一下一大把的。\nPano Scrobbler 是自由软件，支持多种音乐社区平台，界面采用 Material You。鉴于我只在 Android 上听歌，所以只能推荐在 Android 上的 Scrobbler 了。\n下一步 搞好音乐社区平台和 Scrobbler，然后正常听音乐就可以了。\n","date":"2024-07-21T21:57:29+08:00","permalink":"https://mumulhl.eu.org/p/music-track-tutorial/","title":"追踪音乐播放记录"},{"content":"这是新博客的第一篇文章， 是对过去一年的总结。\n这篇文章的缘由 各位看官可能感到奇怪， 对过去一年的总结应该写在年初或者年末才对啊， 这篇怎么写在年中呢？\n去年年初时我写过一篇《年记》， 里边承诺今年按时再写一篇《年记》， 好巧不巧的是， 我把生成博客的文件夹删了， 以至于我无法发那篇文章。 实际上这些都是借口， 博客可以花时间在搞， 但是那篇文章我写都没写。 年初过去了， 接下来要等年末发， 但是我是在有些等不及了， 于是选择现在发这篇文章。\n好， 接下来正式开始回忆过去一年。\n使用的软件 操作系统 刚好一年前， 我装了 Arch Linux， 这时还是双系统， 我保留了 Windows。 前几天我用 Manjaro Linux 替代了 Windows 的位置， 装 Manjaro Linux 的原因是 Arch Linux 出了点问题， 启动速度很慢， 但找不到问题在哪， 想去重装， 不过 Arch Linux 装起来了有点麻烦， 有些东西还得自己手动配置， 于是我选择了 Manjaro Linux。 Manjaro Linux 装起来就是简单， 鼠标点几下就装好了。\n桌面环境 换成 Arch Linux 后就有了桌面环境一说。 最开始按照看的教程安装了 KDE， 用起来还行。\n直到今天一月份， 我感觉 KDE 有许多功能我都用不上， 于是想要去找一个非常简单的桌面环境， 在看 B 站的时候看到了 Hyprland， 我就去找了个配置去用。 Hyprland 需要自己去装很多需要的软件， 例如通知、 软件启动器等等， 给用户极大的自定义空间。\n之后我用上了 EAF， 我给 EAF 提交了很多优化 Hyprland 上的体验的补丁， 但是还不能用得顺手， 于是我换用了 Gnome， 现在我使用的桌面环境就是它。 在 Gnome 上， EAF 用得顺手多了。\n编辑器 我试过不少的编辑器， 比如 VSCodium、 Neovim、 Emacs 等等， 最终使用了 Emacs + Helix， Emacs 是主力， Helix 很少用， 只在终端下使用。\n选择 Emacs 也有个来由， 我觉得编码的时候， 把手在键盘和鼠标之间换来换去， 严重干扰了编码时的思维， 所以我尝试取用全键盘的编辑器。\n最开始用的是 VSCodeium 配上 Neovim 插件， 但是一装好就感觉极大的不适应（原因记不清了， 随便编一个 ）， 故此放弃。\n之后我又尝试了 Neovim， 我抄配置抄得很厉害， 整个配置几百行代码， 没几行出自自己之手。\n后来我看了陈斌大佬的一年成为 Emacs 高手 (像神一样使用编辑器)后， 了解 Emacs 的一些优势， 决心去用用 Emacs， 开始去安装不同大佬的配置来用， 最终尝试失败， 换回了 Neovim。 今年年初不知咋的， 我又想去试试 Emacs， 这次我不去抄配置了， 开始自己动手去写， 这次成功用上了 Emacs， 现在用着很顺手， 想抛弃都做不到。 现在我用的配置是经过多次大规模改写后的， 最开始用 straight + use-package 管理插件， 在参考了懒猫大佬的配置后， 改用了 submodule 管理插件。\n我现在的配置用 lsp-bridge 作为补全插件， 最初我是在看 B 站的时候， 看到了一个关于 lsp-bridge 的视频， 想着试一试没想到上了瘾， 又用上了 EAF、 blink-search、 popweb 等插件， 懒猫大佬开发的插件实在是太好用了， 真是爱不释手， 平时大部分操作依赖他开发的插件。\n开源贡献 在过去一年（2022）我可以肯定的说， 我没有贡献任何代码， 但我从今年（2023）的一月份在 GitHub 上开始开源贡献。 最初我是在用 lsp-bridge 的时候发了一个 =fix typo= 的 PR， 自此开启了每周开源贡献之旅。\n我发的 PR 都是对软件的改进， 例如修复 bug、 拓展功能等等， 这既方便了我的使用， 也方便了其他人的使用。 虽然有些 PR 我已经不用了， 但我仍觉得它依旧有价值。\n开源贡献加强了我的能力， 尤其是代码阅读能力， 最开始给 EAF 添加 Hyprland 的支持时， 代码读起来很不顺， 现在看一个陌生项目， 读得很快。\n开源贡献中有着许多大佬的帮助， 让我知道了代码该怎样写可读性高， 维护成本低。 我主要发 PR 给懒猫大佬的项目， 他对我的 PR 处理很仔细， review 有时处理起来比较麻烦， 但是让我也学到了一些东西。 懒猫大佬还有其他的大佬对我的代码进行过改良， 我都看了那些改进的 commit， 学到了不少。\n我开发了 EAF PyQterminal， 这是一个基于 EAF 开发的终端模拟器， 我原本想要自己去宣传宣传， 但是懒猫大佬抢先我一步， 不仅在 Emacs China 论坛上发了， 还在他的推特上发了， 懒猫大佬人是真的好！ 这个软件开发出来还是有许多问题的， 懒猫大佬不断给我提 issue、 PR， 处理起来要费一点时间， 但是真的好开心， 以前的项目都是无人问津（已经被我删了）， 现在有人来关注我的项目， 多好啊。 这些 issue 和 PR 使得它更加完善， 感谢懒猫大佬！！！\n新博客 新博客与原来的旧博客不同， 换用 Hugo 作为静态网站生成器， 如果以后文章多了， 速度不会像 Hexo 那样慢， 现在还不知道以后文章会不会多起来。\n新博客采用 Hugo BearBlog 作为主题， 我很喜欢这种极简风格的主题， 以前用的主题现在看来有些花哨。\n","date":"2023-06-30T20:17:32+08:00","permalink":"https://mumulhl.eu.org/p/first-post/","title":"过去一年"}]