[{"content":"距离上次的年终总结已经过去一年了（废话），谈谈这一年发生的事吧。\n有技术、生活、3D 等等，跳到自己喜欢的地方看吧。（各部分占比严重失调，因为写了最感兴趣的部分后，就没动力了）\n生活 今年啊，没写多少博文，比 2024 年少多了，今年好像没搞出些过什么名谈，一年就这样过去了。\n收入 回应一下 2024 年终总结，赚到第一桶金了吗？不知道打赏算不算啊。爱发电加上微信打赏的收入大约一百多，感谢所有打赏的朋友们！\n学习 学习更忙了，晚自习时间压根不够，总有一两门学科的作业是抄完的。\n我原以为分班后我会好好学选科科目，但是我错了，时间不足以支撑啊。\n当一名 up 主 成为了一名 B 站 3D 动画区的 up 主，建模、动画、渲染都垃圾得要死，剧本更烂，poimiku 老师是我第一个想达到的目标，更高的目标是狄龙顾大佬（可以说是终极目标了）。\n当 up 主其实不是预期之内的，我想这样可以督促我学习、练习 3D 全流程，提高自己的能力。\n除了 3D 水平外，视频本身的内容也很影响视频的数据。这不是一两句话可以讲得清楚的。\n至于我的 B 站号嘛，其实好找的，但我不想要通过博客来引流，而且我的博客除了 AI 本来就没几个人看。\n尽管未来几年我是不打算开通什么收益的，但希望 2026 年可以突破 1k 粉丝！同时感谢现在所有粉丝们的陪伴！\n3D 今年暑假的时候我开始学习 3D，使用开源软件 Blender。\n以前我是计划学习编曲的，但发现现在所谓流行乐，其实编曲都差不多，听起来一首歌一样，那么 AI 想模仿是极为简单的，花费时间去学编曲实在价值不大，我也没啥天赋，最多只会拿个一两乐器演奏一下。\n尝试过的教程 对于入门教程，我先是学习了小狐狸教程，但我觉得这个教程专注于完成一个案例，学习周期太长。于是我学了 Blendergo 的教程，他的教程有很多案例，每个案例只需几个小时，成就感很强，做得也快。\n接下来计划学习的教程都是些深入的教程，提升水平嘛，目前水平拉完了。\n技术 比赛 今年的一个信息素养比赛晋级到了市级，拿到了一等奖，可惜现场发挥不佳，没能晋级到省级。只有这种比赛能拿个奖，信奥就只能从头到尾摸头了。\n减少维护词悦 词悦是我在 2024 年使用 Flutter 开发的一款开源 mdict 词典，在 Android 上支持最佳，这也是我拿去比赛的项目。\n这个项目目前陷入了这么一个状态：大部分的贡献都来自于我自己，PR 非常少，虽然有很多用户反馈 bug，提功能建议，这依然使得项目的状态很不健康。例如我现在，时间少了，就很难抽出时间去维护了，就会发生 单点故障。\n但是我觉得大部分应有的功能都已经有了，bug 也挺少了，近几个月来的 bug 汇报，其实都很难修复，或者不是这个项目的问题。这还反映出了 Flutter 的问题：Flutter 对系统的一些 API 调用很依赖于社区的包，官方基本没啥支持的，但社区的包又很少，例如 TTS 的包，能用的差不多就只有一个，但是 bug 多，会因为一些外部依赖的更新（如 LLVM），导致没法用。Flutter 不仅自身的向后兼容性不佳，而且极为依赖外部，稳定性就不行，使得维护成本比较高。\n而且词悦需要 Webview，而且需要特殊的用法，Flutter 也就一个包能满足，flutter_inappwebview，而且对桌面的支持很有限，不能发挥 Flutter 跨平台的优势，跨平台跨了个迪奥，基本也就 Android 上能跑。其实不如直接 Android 原生，然后桌面上 Electron 或 Qt，调研过 Tauri，不符合使用需求。\n我还探寻了 KMP 这项跨平台技术，只有 IDEA 和 Android Studio 能开发，然而我的电脑性能有限，跑起 IDE 就很吃力，更别说把项目开发大一点了。试用的时候跟 Gradle 大战了 114514 回合。但是包依然不满足需求。并且这门技术其实正式发布的话还没有多久，还有很大的发展的空间。\nKotlin 是一门很好的语言，语法很优雅（语法糖比较多），写起来挺爽的，跟 Ruby 差不多，能力其实也很强，但是开发体验只有在 JetBrains 的 IDE 上最好。但 JetBrains 在今年开始开发 Kotlin 官方的 LSP，目前还处于 Alpha 状态，值得展望。\n未来想开发的项目 其实我有一个梦，那就是开发出 Ae、Pr、Au 的开源替代品，这方面的开源软件都不是很好用。但，都说了是梦了，哈哈哈😂\n但我真的思考了一下技术选型，和 AI 交流了下。我觉得 Web 技术首先要舍弃，性能不满足需求，对于这样的工业级软件，界面极为复杂，开发效率会很低下。\n对于开源项目来说，没有拿工资的人来工作，本来全靠兴趣，想让软件开发效率更高，那么就要选效率高的技术栈，现代技术栈（差不多近 10-15 年）都不太行，因为这些应用的技术栈构建的界面的目的是，让人人都能会用，对于专业软件来说就很乏力了。\n首先一定的界面要使用拖拽来构建，使用纯代码构建界面就是低效的，越复杂的界面，越难维护。Qt 就很满足需求。其次是使用高效的编程语言，Python 就很适合，可以用 PySide 构建 UI。\n如果遇到需要很强性能的地方，最好要避免 C++，因为和 Python 可以契合得最方便、最好的，其实是用 Rust + PyO3。C++ 的复杂性太高，项目扩大时，在熵增，语言的复杂性是除了人的水平外影响熵增程度很大的因素。当项目很复杂的时候，复杂的语言就会使得性能提升、bug 修复、功能增加变得很困难，再 NB 的人和再好的架构也很难解决语言导致熵增的问题。\nRust 虽然复杂，但是复杂性要比 C++ 低得多，更何况是在 AI 如此强大的情况下，很多很难理解的东西变得简单了。Rust 的设计很严格，可以一定程度上减少人犯错，犯错是不可能避免的，但是是可以减少的。另外说一句，一门的语言的语法咋样其实没啥关系，更重要的是看重语言的特性，语法好不好看是个人审美，是可以改变的，讨论这个意义不大。\n既然都说到 AI 了，那么为什么不直接 Vibe Coding C++ 呢？你不是说 AI 很强大吗？首先 C++ 是有头文件的，AI 对这样的编程语言的实力发挥就很拉了。没体验过，可以去体验一下，不要写那种很常见的应用。其次，AI 无法克服技术本身存在的固有成本，技术垃圾，AI 再 NB 也依然会像人一样撞坑，效率低会低，高会高，无法抹平差异，让所有技术搞起来都一样高的效率（效率只是讨论的一种因素而已），其中一个原因是 AI 基于人的数据训练，人会出的问题，AI 也会出。AI 并非万能，但正确使用依然可以让很多人在效率的提升下被优化掉。（指工作量有限，单人的效率提升，意味着就有人没活干了，被优化掉）。还有一个原因，但我很难用语言描述出来，就是解释为什么固有成本无法被抹平。\n近期想开发的项目 一个开源的音频、BGM、音效管理搜索软件，使用 PySide6 + Rust。\n我和 AI 讨论了很多技术细节，节省了我自己人工做技术调研的时间。\n我现在比较重视开发前的调研，而不是莽撞地开始开发，避免词悦的困境重蹈覆辙。\n总结 太久没写博文了，水平也有点下降了，虽然没人看，但是遵循一个惯例吧。\n","date":"2025-12-31T09:47:25.398Z","permalink":"https://mumulhl.eu.org/p/2025-year-in-review/","title":"2025年终总结：开始学了点3D"},{"content":"Jujutsu 是啥？ Jujutsu（简称 jj）是一款功能强大的软件项目版本控制系统。你可以用它来获取代码副本，跟踪代码变更，最后发布这些变更供他人查看和使用。无论你是新手还是老手，无论你是独自开发全新的项目，还是拥有庞大历史和团队的大型软件项目，它都能让你轻松上手。\n与 Git 兼容 匿名分支 高度自动化的操作（如自动提交） 使用中会有很多友好的提示和指引 Jujutsu 目前基本可用，还缺乏少量功能，如 git submodule 的兼容、tag 的创建。\n我会写一个系列的 Jujutsu 教程，这篇教程是本系列教程的第一篇，只讲一些满足日常操作的东西，学了本篇教程，日常就可以正常使用 Jujutsu 了。在使用 Jujutsu 的过程中，如果出了什么问题，优先看 Jujutsu 自己给的解决方案。\n安装 安装教程见 Jujutsu docs - Installation and setup，我用 Fedora，只能用 carogo-binstall 安装，用这个工具安装不需要从源码编译一遍，会直接从 GitHub 上下载已经编译好的二进制文件，并且 cargo-install-update 也支持通过这个工具更新安装的二进制文件。\n初始化仓库 无论你是从零开始，还是在现有 Git 仓库的基础上进行初始化，都推荐用下面这个命令：\n1 jj git init --colocate . 该命令可以从 .git 初始化 .jj 或者同时初始化 .jj 和 .git。如果用 jj init 初始化，会只有 .jj，但 Jujutsu 目前又无法从 .jj 初始化 .git，用 git init 自己手动初始化一个也没用，会没法从 .jj 同步。Jujutsu 目前不支持创建 tag，如果要创建 tag，就要用到 Git，如果没有 .git，就会很抓狂，虽然可以解决，但要麻烦一点，别问，问就是踩坑了。\n配置名称和邮箱 1 2 $jj config set --user user.name \u0026#34;Example\u0026#34; $ jj config set --user user.email \u0026#34;example@example.com\u0026#34; 第一个提交 Jujutsu 中你不需要 提交（commit） ，但是需要 describe ，在仓库下做了一些改动后，或改动之前，或改动中，都可以用 describe 命令来解释改动，这个命令的简写是 desc：\n1 2 3 $ jj desc -m \u0026#34;First commit\u0026#34; Working copy (@) now at: pwquumlq ae3142c8 First commit Parent commit (@-) : zzzzzzzz 00000000 (empty) (no description set) Working copy 指的是当前正在工作的 copy，可以任意更改，如果是 Git 的话，如果要修改一个 commit，就要手动操作下，这就体现了 Jujutsu 的自动化。pwquumlq 是 Jujutsu 的 id，ae3142c8 是对应的 Git 的 id。在之后的操作中可以用 @ 指代。\nParent commit 指的是上一个提交（父提交）。这里的 zzzzzzzz 00000000 说明父提交是 根（root） 。(empty) 表示这个 commit 是空的。(no description set) 表示这个 commit 没有 description。在之后的操作中可以用 @- 指代（多了一个减号）。\n在终端中你会看到 zzzzzzzz 中的第一个 z 是高亮的，working copy 的 id 的第一个字母也是高亮的，高亮的字母 是 commit id 的简写，可以用来指代该 commit。直接高亮出来，方便很多，用终端操作的要比 GUI 快。\n移动到新的 working copy 一个 commit 已经完成了，然后我们要移动到新的 working copy 进行接下来的工作：\n1 2 3 $ jj new Working copy (@) now at: qzmssurw 17a91560 (empty) (no description set) Parent commit (@-) : pwquumlq ae3142c8 First commit 或者你可以在改动完后把 describe 和 new 操作用 commit 命令一起完成，有多种方案，很灵活：\n1 $ jj commit -m \u0026#34;First commit\u0026#34; 分叉 new 命令还可以从一个提交 分叉 出去，在用下面讲到的查看历史提交中就会看到分成了两条链：\n1 $ jj new [jj id] 查看历史提交 可以直接运行 jj 来查看历史提交，相当于 jj log，输出的结果会省略一部分提交，这里提交数量太少了，Jujutsu 不会省略：\n1 2 3 4 5 6 $ jj @ qzmssurw mumulhl.666@gmail.com 2025-07-10 21:04:39 17a91560 │ (empty) (no description set) ○ pwquumlq mumulhl.666@gmail.com 2025-07-10 20:56:41 git_head() ae3142c8 │ First commit ◆ zzzzzzzz root() 00000000 这是省略的样子，(elided revisions) 会替代掉一部分提交：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ jj @ ovqtlklr mumulhl.666@gmail.com 2025-07-09 21:07:36 030cb30c │ (empty) (no description set) ◆ ruvroqot mumulhl.666@gmail.com 2025-07-09 21:07:26 main git_head() 59603f61 │ Sync vibe coding rules ~ (elided revisions) │ ○ zsxqkykv mumulhl.666@gmail.com 2025-06-28 16:38:36 edf292f1 ╭─┤ (empty) Merge pull request #413 from mumu-lhl/push-xpztozvsopvq ◆ │ xpztozvs mumulhl.666@gmail.com 2025-06-28 16:30:59 9fcc6e8e │ │ Add changelog button to about page ~ │ (elided revisions) │ ○ uvknsurt mumulhl.666@gmail.com 2025-06-28 15:48:48 70913779 │ ├─╮ (empty) Merge pull request #411 from weblate/weblate-ciyue-app ...... 查看完整的历史提交也是没问题的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ jj log -r \u0026#39;all()\u0026#39; @ ovqtlklr mumulhl.666@gmail.com 2025-07-09 21:07:36 030cb30c │ (empty) (no description set) ◆ ruvroqot mumulhl.666@gmail.com 2025-07-09 21:07:26 main git_head() 59603f61 │ Sync vibe coding rules ◆ smoxoopp mumulhl.666@gmail.com 2025-07-08 21:56:35 4403614c ├─╮ (empty) Merge pull request #431 from mumu-lhl/push-xmlopqwnzwuo │ ◆ xmlopqwn mumulhl.666@gmail.com 2025-07-08 21:52:31 261fa48b │ │ Refactor Consumer to Selector on wordbook page │ ◆ tmklvsky mumulhl.666@gmail.com 2025-07-08 21:31:40 af9826b7 ├─╯ Add multiselectmode on wordbook page ◆ wlprsvrq mumulhl.666@gmail.com 2025-07-08 13:44:04 d31b7cf5 ├─╮ (empty) Merge pull request #430 from mumu-lhl/push-kkmymxosqwvr │ ◆ kkmymxos mumulhl.666@gmail.com 2025-07-08 11:17:33 0245d789 ├─╯ Add storage management ◆ unquwrst mumulhl.666@gmail.com 2025-07-08 08:42:11 7e6a3a76 ├─╮ (empty) Merge pull request #428 from mumu-lhl/dependabot/pub/gpt_markdown-1.1.2 │ ◆ svqpznzp 49699333+dependabot[bot]@users.noreply.github.com 2025-07-08 08:28:35 e70cca3f │ │ chore(deps): bump gpt_markdown from 1.1.1 to 1.1.2 ...... 编辑提交 Jujutsu 中提交可以被轻松的编辑：\n1 $ jj edit @- # 编辑父提交 编辑完后回去：\n1 $ jj next --edit 是不是要比 Git 简单得多？\nSquash 我们想要编辑的提交，往往都是父提交，例如忘了 format 或写错了一小点东西的时候，我们可以用 squash 更快的完成这步操作，这个命令是把当前 workng copy 的更改合并到父提交上：\n1 $ jj squash 运行完这行命令后，当前 working copy 就会变成空的，因为合并到了父提交中。\n推送提交 先加 remote，因为 Jujutsu 是与 Git 兼容的，所以可以直接推送到 Github 上，不需要 JJhub：\n1 $ jj git remote add origin [远程仓库地址] Jujutsu 中有 分支（Branch） 的平替概念—— 书签（Bookmark），但是书签一旦被 set，不会跟随当前的 working copy 的变动而改变，需要手动再次 set，才会变。\n现在我们的仓库连 main 书签都没有，这个命令可以把书签 set 到当前 commit 上，如果不存在会自动创建。确保当前的 working copy 不是空的，如果是的话可以用 jj edit @- 编辑父提交，使当前的 working copy 变成父提交：\n1 $ jj b s main # b 是 bookmark 的缩写，s 是 set 的缩写 推送到远程仓库：\n1 $ jj git push 当对某个过去的提交更改后，推送是不需要加 \u0026ndash;force 之类的参数的，爽了很多。\n抛弃一个提交 如果你不想要当前 working copy 的更改或最新的提交，可以抛弃掉：\n1 $ jj abandon [jj id] 注意：不要随意抛弃过去的提交，会导致冲突，很难处理，如果要合并过去的提交，可以用 squash 命令，这个命令更强大的用法将在下一篇教程中讲到。\n撤销 当你后悔了一个操作的时候，就需要撤销，撤销操作也是非常的简单：\n1 $ jj undo 推送到额外的分支上 不是所有项目我们都会一律把提交 直接 推送到 main 分支上，按照 Github flow，至少要推送到其他分支上，然后发一个 PR 合并到 main 上。\n只需要在推送到远程仓库的命令上多加几个字符就可以了：\n1 $ jj git push -c@ # -c 后跟随要推送到仓库的提交，比该提交旧的提交也会一起推送上去，这里用 @ 指代当前 working copy 这种方法推送上去的分支名是 push-[jj id]，当然可以自己在本地先 set 了书签，然后再用 jj git push 推送。我比较懒不太喜欢给分支命名，因为 PR 名称就可以诠释一堆的提交是干什么的了，减少心智负担。\n在同一个仓库里（多个维护者），如果每个人提交的都是默认的那种 push-[jj id]，完全会乱套，我们可以把默认的分支名变成 yourname/push-[jj id] 这样去稍微做一点区分。编辑配置文件 .config/jj/config.toml（用 jj config p 查看配置文件路径），加入以下内容：\n1 2 [templates] git_push_bookmark = \u0026#39;\u0026#34;example/push-\u0026#34; ++ change_id.short()\u0026#39; 拉取 远程仓库做了一些更改，需要把提交都拉取到本地仓库：\n1 $ jj git fetch main 书签 set 的提交也自动变化了，但是通过运行 jj 你会看到当前 working copy 并不在 main 的那条链上，所以需要我们自己手动一下去移动到 main 那条链上：\n1 $ jj new main 结语 用了一段时间的 Jujutsu 后，Jujutsu 基本已经平替了 Git，只能用一个字来说用的体验——爽。\n虽然没有多少有价值的学习资料，边用边学的过程中，基本也用个会了，因为操作起来真的很简单。\n下一篇教程会深入讲解 Jujutsu 的使用，敬请期待 :)\n","date":"2025-07-10T21:59:21+08:00","permalink":"https://mumulhl.eu.org/p/jujutsu-1/","title":"Jujutsu入门教程：比Git更好用的VCS"},{"content":"之前看见一名推友说自己用 AI 结对写小说，发表到番茄小说上，遇到了没有流量的问题，番茄小说的一些规则其实它都写了，但要细品，不然怎么让你在上面发小说呢？\n这里我就来梳理一下番茄小说写作的一些规则，可能都是我比较在意的。\n签约条件 年龄要求如下：\n16 岁以下不能签约 16-18 岁需要监护人的身份证和手机号码 18 岁以上不用说 为什么小说发表没有流量：推荐要求 番茄必须要签约后才会对小说进行推荐，在签约前想要有流量，只能自己想办法引流。\n你有继续发小说吗？ 没有了，我被挡在了签约条件第二条，发表的小说在签约前没有流量，我不知道值不值得签约，要是签约后不通过或是流量很差，我也没脸啊！会很后悔的！\n审核严格吗？ 审核似乎不是编辑在审，过不过审跟作品质量无关。审核速度非常快，快的话几分钟就过了（可怜勤勤恳恳的审核员\u0026hellip;）。\n能用 AI 写小说吗？ 番茄官方的作家助手 app 里是有 AI 助写的功能的，使用有限制，也应该是番茄的一种态度吧，大概能用，但是不要全用 AI 给写完了，即使过了审，如果被编辑或读者看出了，那就不好说会怎么样了。\n结尾 这篇文章很短，我猜你点了进来，可能对你有帮助吧。后续是我准备试试知乎的盐选小说的水，看了下规则，好像审核非常严，是编辑在审稿，每次投稿都会多次审核，不知道写出来能不能。但是现在，我得马上赶作业了\u0026hellip;\n","date":"2025-06-09T11:50:11.331Z","permalink":"https://mumulhl.eu.org/p/%E7%95%AA%E8%8C%84%E5%B0%8F%E8%AF%B4%E5%86%99%E4%BD%9C%E8%AF%95%E6%B0%B4/","title":"番茄小说写作试水"},{"content":"很久很久之前写了一篇在 Linux 上如何把 Android 作为麦克风的教程，不久前因为要用 Windows 上的一些软件，装上了 Windows，顺便折腾个在 Windows 上的把 Android作为麦克风的方案。\n找了很久，没有找到既方便又开源的方案，一些免费的方案（如 WO Mic）音质不太行，自己摸索了一方，最后用 Scrcpy 和 VB-CABLE 实现了。关键是 不需要在 Android 上安装任何软件！\n使用 Scrcpy 把 Android 作为麦克风理论上在 Linux 和 macOS 上也可以，在音频驱动那里会有点不同。\n确保 Android 版本 \u0026gt;= 11\n安装 Scrcpy 首先是 Scrcpy，它将用于从 Android 转发音频，可以在 Github Release 页面 下载对应的压缩包再解压，32 位下载 scrcpy-win32-vX.X.zip，64 位下载 scrcpy-win64-vX.X.zip。\n最好的办法是直接通过 Windows 的包管理器 winget 安装：\n1 winget install --id=Genymobile.scrcpy VB-CABLE VB-CABLE 的用途是将音频由输出转到输入。\n前往 VB-CABLE官网，点击 VBCABLE_Driver_Pack45.zip 下载压缩包，解压后，双击执行 VBCABLE_Setup_x64.exe（64 位）或 VBCABLE_Setup.exe（32 位）安装。然后就好了很么都不用动。系统 \u0026gt; 声音 \u0026gt; 输入 应该会自己变成 CABLE Output。\n正式步骤 Android 上开启 USB 调试 具体步骤见 Android Developer 文档。\n运行 Scrcpy 命令 如果通过压缩包获取 Scrcpy 点击解压后目录里的 open_a_terminal_here.bat 在该目录下打开终端。通过 winget 安装 Scrcpy 直接打开终端即可。\n接着运行：\n1 scrcpy --no-video --no-control --audio-source=mic-unprocessed 第一次运行 Android 上会要求授权，授权即可。\n参数解释：\n--no-video 不要画面 --no-control 不要控制 --audio-source=mic-unprocessed 将声音源指定为未处理的麦克风音频 声音源还有很多选项，完整选项见 Audio 文档，我觉得 mic-unprocessed 音质是最好的，也可以试试别的，简单列举几个：\nmic: 捕获麦克风 mic-unprocessed: 捕获未处理（原始）的麦克风声音 mic-camcorder: 捕获为录制视频调优的麦克风声音，如果可用，其方向与摄像头相同 mic-voice-recognition: 捕获为语音识别调优的麦克风声音 mic-voice-communication: 捕获为语音通信调优的麦克风声音（例如，如果可用，它会利用回声消除或自动增益控制） 改变音谱输出设备 在 系统 \u0026gt; 声音 \u0026gt; 音量合成器 \u0026gt; 应用 将 Scrcpy 创建的窗口的 输出设备 更改为 CABLE Input，现在通过 Android 麦克风输入的音频就不会从扬声器里输出了，会从输入设备 CABLE Output 里输出。\n","date":"2025-04-30T14:31:56.036Z","permalink":"https://mumulhl.eu.org/p/%E6%B2%A1%E9%BA%A6%E6%80%8E%E4%B9%88%E5%8A%9E%E6%8A%8A%E6%89%8B%E6%9C%BA%E5%BD%93%E4%BD%9C%E9%BA%A6%E5%85%8B%E9%A3%8Escrcpy-%E7%AF%87/","title":"没麦怎么办，把手机当作麦克风！（Scrcpy 篇）"},{"content":"Imagen 3 Imagen 3 是 Google DeepMind 最新的文生图模型，可以在 ImageFx 免费使用。Imagen 3 在 Gemini 内也是可以使用的，Gemini 生成图片有时会不听话，不生成图片，所以本文采用 ImageFx。\n如何实现人物一致性？ 主要有两种方式：\n对现有的人物图像进行“引用”，如 Midjourney 对人物描述相当详细的 Prompt，基本适用于各种文生图模型 第一种方式 Imagen 3 不支持，本文就采用第二种。\n创造人物形象 想要有一个对人物描述相当详细的 Prompt，由人来写就太繁琐了，可以提供一些人物的特征让大语言模型帮我们写，这里采用 Gemini 2.0 Flash Thinking 模型。给出的特征越详细越能生成符合自己想要的人物。\n示范 Prompt：\n1 2 3 4 5 6 7 8 9 10 11 12 13 你是一名文生图prompt专家，请写一个英文prompt去生成一个人物，将prompt放入代码块中。 prompt要求： 1. 无背景 2. 全身图 人物： 1. 白色头发 2. 穿白里带红的和服 3. 20岁左右的女性 4. 日本动漫风格 注：不要想着生成loli什么的，生成图片时会被判定为“儿童”而无法生成！\n先用大语言模型写的 Prompt 生成一下，如果效果不错，把种子锁定下，最好把种子保存下，方便以后生成尽可能相似的人物。\n根据人物创造详细的 Prompt 下载一张图片，发给支持图像的大语言模型，并让它根据图像创造出详细的 Prompt。\n示范 Prompt：\n1 你是一名文生图prompt专家，请写一个英文prompt去描述图像人物，将prompt放入代码块中。 把人物嵌入图像中 首先先生成一个生成人物坐在桌前写作业的图片的Prompt。\n示范 Prompt：\n1 2 3 4 5 6 7 你是一名文生图prompt专家，请写一个英文prompt去生成一张图片，将prompt放入代码块中。 要求： 1. 用 [CHARACTER] 代替人物 2. 人物坐在一张桌子前写作业 3. 氛围温馨 我们将使用 [CHARACTER] 代指人物，然后把上一个步骤生成的 Prompt 拼接进去，如：\n1 2 3 [CHARACTER] sitting at a wooden desk, writing homework in a softly lit room, warm atmosphere, cozy, desk lamp, books, study, home, peaceful, detailed, realistic. [CHARACTER]: 1girl, full body, Tomoe Gozen, white hair, long hair, white kimono, red and gold floral pattern, standing, arms outstretched, black background 最终效果图：\n","date":"2025-02-16T03:08:28.183Z","image":"https://mumulhl.eu.org/p/imagen-3-tutorial/cover_hu_572d20d4b43bd6d1.webp","permalink":"https://mumulhl.eu.org/p/imagen-3-tutorial/","title":"Imagen 3: 免费文生图工具保持人物一致性"},{"content":"（封面来自 Unsplash，作者 BoliviaInteligente）\n2024年结束了，2025年来了，转眼又是一年了。2024给我最大的震撼就是AI的辅助带来的便捷，过去稍有接触AI，但是没有太深入地使用，导致也用不好。\n真正对 AI 的接触 看到 X 上有很多大佬用 Cursor 开发出了一些项目，就有点手痒痒了。过去我使用的编辑器是 Helix，一个全键盘编辑器，感觉效率会高一些。如果要用 Cursor 这样的 AI 编辑器就要脱离全键盘的操作了，但是 AI 能提高我的开发效率的话，没有了全键盘操作也不算亏。于是 Cursor 就取代 Helix 在我的电脑上的地位。\nCursor 让我震撼的是，在编辑一块代码的时候，居然可以按 Tab 键去补全其他部分相关的代码，以前我以为 AI 代码补全就只能像补全变量名、函数名那样补全，这完全打破了我的认知啊！\n最早使用 AI 我都倾向于想用一句话让 AI 完成我想要做的有点复杂的事，但在理论上是不可行的，事实上也是不行的。只用一句话去表述一件较为复杂的事，信息量很少，难以去描述细节，AI 自然无法做到和自己所想的相符。和人说件事，说话只说一句，得让对方多疯狂，更别说是 AI 了。在我的使用体验来说，AI 更适合去做小任务，而非是复杂的大任务，如果要让 AI 去做大任务，将它分解为多个小任务效果会更好。\nAI 的使用体验总结起来就是一个字——“爽”，每周最多一天的时间里我可以开发得更高效。\n开源让我学到了很多 2024年新开发的项目主要实在暑假里开发的，好几个我都觉得不太行，所以只挑出我最经常维护的词悦来说吧。\n词悦是一个开源的支持 mdict 格式的词典，是我觉得 Android 上没有简洁、好用的开源的 mdict 词典而开发的。虽然最初发布的时候很简陋，不过现在经过几个月的开发，已经完善了许多了。\n最初词悦用 git-cliff 生成版本发布时的更新日志，后来我才慢慢在词悦中把 Github 的 label、milestones 功能好好用上，现在词悦的版本更新日志是由 Github 生成的，这样可以把这个版本贡献者直接显示在更新日志中。\n词悦还提交到了 F-Droid 上，我还提交过几个 MR，但是水平不太够，没办法，犯了很多低级错误，都由 linsui 大佬纠正了，感谢 linsui 大佬不知疲倦地修改我的 MR！\n在开源中，我学会了许多以前不知道的技巧、技术，开源不仅利他，还能利己。\n重启博客 2024，我重启了我的博客，一年的文章就是2023的十几倍了（2023只有一篇文章）。2024我写了15篇博文，其中大部分都是在暑假写的。暑假闲来无事重启了博客，还把博客主题换成了 Stack。我还把博客提交到 V2EX VXNA、博友圈等平台上，我的博客也终于不再是我自娱自乐的地方了。\n对2025的展望 希望我可以在2025把 AI 使用得更加得心应手吧；希望我能在2025凭借自己的能力去赚到人生第一桶金，哪怕没几块也行哪。\n","date":"2025-01-01T02:07:26.855Z","image":"https://mumulhl.eu.org/p/2024-year-in-review/2024_hu_3599eb9c704ea10e.jpg","permalink":"https://mumulhl.eu.org/p/2024-year-in-review/","title":"2024年度总结：AI原来能这么好用"},{"content":"最近在开发词悦（一个 mdict 词典）的时候，需要支持全局上下文菜单，查了很多资料都没有找到合适的方法，问了下 cursor，得到了初步方案，经过稍微的改动就有了这篇教程。\n本文开发环境在 Linux 下。\n初始化项目 1 2 flutter create example cd example 写代码 Manifest 编辑 android/app/src/main/AndroidManifest.xml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- 省略... --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;io.flutter.embedding.android.NormalTheme\u0026#34; android:resource=\u0026#34;@style/NormalTheme\u0026#34; /\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;!-- 新增的部分 --\u0026gt; \u0026lt;!-- android:label 是上下文菜单中显示的名称 --\u0026gt; \u0026lt;activity android:name=\u0026#34;.ProcessTextActivity\u0026#34; android:label=\u0026#34;example\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.PROCESS_TEXT\u0026#34; /\u0026gt; \u0026lt;data android:mimeType=\u0026#34;text/plain\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; 原生 Android 创建 android/app/src/main/kotlin/com/example/example/ProcessTextActivity.kt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.example import android.app.Activity import android.content.Intent import android.os.Bundle import io.flutter.embedding.android.FlutterActivity class ProcessTextActivity : Activity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val text = intent?.getCharSequenceExtra(Intent.EXTRA_PROCESS_TEXT)?.toString() ?: \u0026#34;\u0026#34; val intent = Intent(this, MainActivity::class.java).apply { action = Intent.ACTION_PROCESS_TEXT putExtra(Intent.EXTRA_PROCESS_TEXT, text) addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK) // 如果不加这个 flag，app 在后台运行时无法把选中的文本传给 Flutter } startActivity(intent) finish() } } 编辑 android/app/src/main/kotlin/com/example/example/MainActivity.kt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.example import android.content.Intent import android.os.Bundle import io.flutter.embedding.android.FlutterActivity import io.flutter.embedding.engine.FlutterEngine import io.flutter.plugin.common.MethodChannel class MainActivity: FlutterActivity() { private val CHANNEL = \u0026#34;com.example.example/process_text\u0026#34; private var methodChannel: MethodChannel? = null override fun configureFlutterEngine(flutterEngine: FlutterEngine) { super.configureFlutterEngine(flutterEngine) methodChannel = MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) if (intent?.action == Intent.ACTION_PROCESS_TEXT) { val text = intent.getCharSequenceExtra(Intent.EXTRA_PROCESS_TEXT)?.toString() ?: \u0026#34;\u0026#34; methodChannel?.invokeMethod(\u0026#34;processText\u0026#34;, text) } } } Flutter 部分 编辑 lib/main.dart:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:flutter/services.dart\u0026#39;; void main() { WidgetsFlutterBinding.ensureInitialized(); platform.setMethodCallHandler((call) async { if (call.method == \u0026#34;processText\u0026#34;) { final text = call.arguments as String; // call.arguments 里就是选中的文本了 print(text); } }); runApp(const MyApp()); } const platform = MethodChannel(\u0026#34;com.example.example/process_text\u0026#34;); 结尾 接下来怎么样就靠你的想象力了 :)\n","date":"2024-11-30T15:16:10.308Z","permalink":"https://mumulhl.eu.org/p/%E7%BB%99flutter-android-app%E6%94%AF%E6%8C%81%E5%85%A8%E5%B1%80%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95/","title":"给Flutter Android App支持全局上下文菜单"},{"content":"当我们像在仅需要在局域网内进行直播这种情况时，就可以自己动手搭建极简的直播服务。\n预备知识 会写一点点 nginx 配置。\n概念 RTMP 用于流媒体传输的协议，最初用于 Flash 播放器，也可以用于直播。\n本教程中，我们将用该协议将直播流推送至 nginx 服务器。\nHLS 基于 HTTP 流媒体传输协议，它将流分割成多个文件传输，对于直播流，以 m3u8 文件为播放列表，以 ts 文件为视频。\n本教程中，该协议用于向浏览器传输直播流。\n编译 nginx nginx 本身并不支持 RTMP 协议，需要把 nginx-rtmp-module 模块编译进 nginx。\n从 nginx.org 下载 nginx 源码，解压后进入目录。\n然后克隆 nginx-rtmp-module 源码：\n1 git clone https://github.com/arut/nginx-rtmp-module --depth=1 编译并安装 nginx：\n1 2 3 ./configure --add-module=nginx-rtmp-module make make install 最后 /usr/local/nginx/sbin 添加到环境变量 PATH 中。\n前端 一般浏览器不能直接播放 HLS，这里采用 DPlayer + hls.js 用于播放 （因为好看）。\n从 这里 还有 这里 下载 DPlayer.min.js 和 hls.min.js 到 /usr/local/nginx/html/。\n将 /usr/local/nginx/html/index.html 改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;直播\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;dplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;hls.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;DPlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const dp = new DPlayer({ container: document.getElementById(\u0026#39;dplayer\u0026#39;), autoplay: true, // 自动播放 live: true, // 直播 video: { url: \u0026#39;/live/example.m3u8\u0026#39;, // 等下 example 改成自己的推流码 type: \u0026#39;hls\u0026#39;, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打开首页就是播放器。\n配置 将 /usr/local/nginx/html/conf/nginx.conf 改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 worker_processes 1; events { worker_connections 1024; } rtmp { server { listen 1935; chunk_size 4000; application live { # /live 是推流地址 live on; hls on; hls_path html/live; } } } http { server { listen 8080; location / { root html; add_header Cache-Control no-cache; } } } 关于 nginx-rtmp-module 更多配置见 wiki。\n不用担心 HLS 的 ts 文件会无限增加下去，nginx-rtmp-module 会删除老的 ts 文件。\n启动 nginx：\n1 nginx 推流 这里推流使用 OBS Studio。\n在“设置”-“直播”中填写“服务器”为 http://localhost:8080/live，“推流码”填自己想要的，但 index.html 中的 example 要改成这个推流码，不然没法播放直播。\n配置好来源就可以开始直播啦~\n试试看 打开 http://localhost:8080 就可以看到直播了，大概会有 10s 左右的延迟。\n正式使用时，请根据自己的需求更改。\n结语 过去，学校里的大型表演，能到现场看的人数有限，不是所有人都能到现场看，而且没有直播。再过不久有一个歌唱比赛（我当然去参加海选了，只不过没选上），我想搭建一个直播服务去直播这些表演，于是就有了这篇教程。因为能否直播还要征得校方同意，所以不一定能用得上\u0026hellip;\n","date":"2024-09-30T20:31:22+08:00","permalink":"https://mumulhl.eu.org/p/nginx-live-service/","title":"nginx 搭建极简直播服务"},{"content":"介绍 Material You 加入到 Android 12 中，其中包括了动态配色。\n用户可以直接在系统层面上很方便地改变系统配色和支持动态配色的软件的配色。开发者也不需要再开发配色功能。\n设置 （因为不同厂商把选项名改得不一样，所以很难明确写出选项的名称）\n打开设置 点击一个名称大致包含了 桌面、壁纸 的选项 点击名称像 系统风格 的选项，就可以选择颜色了。 可以单独选择配色，也可以从壁纸上提取出颜色。\n结语 用了 Android 13 一整年了，都不知道有这个功能 😂 最近用 Flutter 开发词典的时候才了解到。\n","date":"2024-08-15T15:25:12+08:00","permalink":"https://mumulhl.eu.org/p/android-dynamic-color-tutorial/","title":"给 Android 换个配色"},{"content":"你的电脑可能没有麦克风，需要的时候，又不想买一个麦克风，这时候就可以把你的 Android 当作麦克风来用。\nAudio Source 是一个用 ADB 将 Android 麦克风的输入转发到 PulseAudio 进程的工具。\n准备 一只手 Android 4.0 及以上 一条 USB 数据线，充电线也没问题 PATH 中包含 python3、pactl、adb（Archlinux 如果没有 adb，用 sudo pacman -S android-tools 安装，安装后需重启） 使用 Android 端 可在 Releases 页面下载，或在 IzzyOnDroid F-Droid Repository 下载。\n安装后，点开软件，如果没看到 UI 很正常，这个软件就是没有 UI 的\u0026hellip; 然后要授权软件麦克风和通知权限，如果授权权限的弹窗闪退，可以在 设置 里面授权软件权限。\nLinux 端 下载 audiosource 脚本并授权可执行权限。\n1 curl -O https://raw.githubusercontent.com/gdzx/audiosource/master/audiosource \u0026amp;\u0026amp; chmod +x audiosource 用 USB 数据线连接手机和电脑，在 开发者选项 里开启 USB 调试模式。\n用 adb 查看一下连接的 Android 设备，这时手机会弹出授权窗口，点授权就完事了。授权完再运行一下这个命令，看看是否正常。\n1 adb devices 运行 audiosource 脚本，你的 Linux 就有麦克风啦 :)\n1 ./audiosource run 结语 Audio Source 是我意外在 F-Droid 找到的，F-Droid 上的宝藏很多 :)\n","date":"2024-08-11T12:40:00+08:00","permalink":"https://mumulhl.eu.org/p/audio-android-to-linux/","title":"将 Android 作为 Linux 的麦克风"},{"content":"yt-dlp 是一个功能强大的命令行音频、视频下载器。yt-dlp fork 自基于 youtube-dl 的已不维护的 youtube-dlc，具有额外的功能和问题修复。\nyt-dlp 不仅支持 YouTube，还支持一千多个网站。除了下载音频、视频，还能下载封面。\n安装 可以通过 pip 安装，也可以通过你所用的系统的包管理器安装，还可以到 release 页面下载可执行文件。\n1 2 3 pip install yt-dlp # or pipx install yt-dlp 使用 视频 直接加链接即可。\n1 yt-dlp \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 可以下载一整个播放列表的视频。\n1 yt-dlp \u0026#34;https://www.youtube.com/playlist?list=PLp8YAQVH95dwCMvzkxUhFy4KWRAtp_awf\u0026#34; 还可以下载 m3u8。\n1 yt-dlp \u0026#34;https://example.com/index.m3u8\u0026#34; 列出视频可以下载的格式，也列出了传输协议、格式、分辨率、帧率、大小等信息。\n1 2 3 yt-dlp -F \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; # 与下面的命令等价 yt-dlp --list-formats \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; yt-dlp 默认会下载分辨率、帧率等最好的视频，如果要指定相应的分辨率、帧率，要用 --format-sort/-S 参数。\n下载分辨率不优于 720p 的视频，也就是下载 720p 的视频。\n1 yt-dlp -S \u0026#34;res:720\u0026#34; \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 指定视频的容器格式。\n1 yt-dlp -S \u0026#34;ext:webm\u0026#34; \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 用 , 连接多个限制条件。\n1 yt-dlp -S \u0026#34;ext:webm,res:720\u0026#34; \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 嵌入元数据，默认不嵌入。\n1 yt-dlp --embed-metadata \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 嵌入封面，默认不嵌入。\n1 yt-dlp --embed-thumbnail \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 嵌入字幕，默认不嵌入。仅支持 mp4、mkv、webm 容器的视频\n1 yt-dlp --embed-subs \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 音频 分离出视频中的音频。\n1 2 3 yt-dlp -x \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; # 与下面的命令等价 yt-dlp --extract-audio \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 指定音频的格式和品质，品质取值 0-10，0 最佳，10 最差，默认为 5。\n1 yt-dlp -x --audio-format opus --audio-quality 0 \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 嵌入元数据。\n1 yt-dlp -x --embed-metadata \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 封面 列出所有封面。\n1 yt-dlp --list-thumbnails \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 下载封面，同时会下载视频。\n1 yt-dlp --write-thumbnail \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 下载所有封面，不会下载视频。\n1 yt-dlp --write-all-thumbnails \u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34; 结语 写不出什么结语了(liao) :(\n","date":"2024-08-10T20:59:35+08:00","permalink":"https://mumulhl.eu.org/p/yt-dlp-tutorial/","title":"yt-dlp 教程"},{"content":"Dict_reader 是一个用于读取 mdict 词典的 Dart 语言库，支持 MDX/MDD 格式。\nREADME 提供了几个示例，本文提供更适合生产环境的示例。\n安装 1 dart pub add dict_reader 使用 在生产环境中，会用到搜索单词、查看单词的功能，而且必须要高效，这时候轮到 SQLite 数据库出场了。在第一次读取词典时，用 Drift 存储少量数据，用于之后快速地搜索和查看。\n安装 Drift 1 dart pub add drift drift_flutter dev:drift_dev dev:build_runner 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // database.dart import \u0026#34;package:dict_reader/dict_reader.dart\u0026#34;; import \u0026#34;package:drift/drift.dart\u0026#34;; import \u0026#34;package:drift/native.dart\u0026#34;; import \u0026#34;dart:io\u0026#34;; part \u0026#39;database.g.dart\u0026#39;; @TableIndex(name: \u0026#39;idx_keyText\u0026#39;, columns: {#keyText}) class Dictionary extends Table { TextColumn get keyText =\u0026gt; text()(); IntColumn get recordBlockOffset =\u0026gt; integer()(); IntColumn get startOffset =\u0026gt; integer()(); IntColumn get endOffset =\u0026gt; integer()(); IntColumn get compressedSize =\u0026gt; integer()(); } @DriftDatabase(tables: [Dictionary]) class AppDatabase extends _$AppDatabase { // After generating code, this class needs to define a `schemaVersion` getter // and a constructor telling drift where the database should be stored. // These are described in the getting started guide: https://drift.simonbinder.eu/getting-started/#open AppDatabase() : super(_openConnection()); @override int get schemaVersion =\u0026gt; 1; Future\u0026lt;void\u0026gt; insertUsers(List\u0026lt;DictionaryCompanion\u0026gt; dictionary) async { await batch((batch) { batch.insertAll(this.dictionary, dictionary); }); } Future\u0026lt;List\u0026lt;DictionaryData\u0026gt;\u0026gt; searchWord(String word) { return (select(dictionary)..where((u) =\u0026gt; u.keyText.like(\u0026#39;$word%\u0026#39;))).get(); } static QueryExecutor _openConnection() { return NativeDatabase(File(\u0026#39;dictionary.db\u0026#39;)); } } void main() async { final database = AppDatabase(); final dictReader = DictReader(\u0026#34;MDX FILE PATH\u0026#34;); // 不用获取 keyText 和 offset 存入数据库时，可以传入 false 参数 await dictReader.init(); // 将 keyText 和 offset 存入数据库，只需一次 var queue = \u0026lt;DictionaryCompanion\u0026gt;[]; await for (final ( keyText, (recordBlockOffset, startOffset, endOffset, compressedSize) ) in dictReader.read()) { queue.add(DictionaryCompanion( keyText: Value(keyText), recordBlockOffset: Value(recordBlockOffset), startOffset: Value(startOffset), endOffset: Value(endOffset), compressedSize: Value(compressedSize))); } await database.insertUsers(queue); // 通过数据库搜索单词 final result = (await database.searchWord(\u0026#34;go\u0026#34;))[0]; // 获取单词数据 print(await dictReader.readOne(result.recordBlockOffset, result.startOffset, result.endOffset, result.compressedSize)); await database.close(); } 然后生成 database.g.dart 文件：\n1 dart run build_runner build 这个示例不适合直接放到生产环境中，稍微改一下就可以了。\n结语 Dict_reader 主要是翻译 mdict-analysis。我对 Dart 不是很熟，在翻译过程中经常去问 gpt-4o-mini 以及 SearchGPTool，有帮助也有捣乱，最终还是花了四天时间完成。\nDict_reader 并没有完全翻译，而且挑选了最重要、有意义的部分翻译，也基于我自身考虑（我手头没有 mdict 格式 3.0 版本的词库），例如没有校验、不支持 lzo 压缩、不支持 mdict 格式的 3.0 版本，但不影响一般使用。\n","date":"2024-08-09T17:56:10+08:00","permalink":"https://mumulhl.eu.org/p/dict-reader-tutorial/","title":"Dart 中读取 mdict 词典教程"},{"content":"最近趁着暑假学钢琴，但家里没有钢琴，于是舅舅送了我一台电子琴。\n这台电子琴型号是 MK-2089，61 键，255 种音色，255 种伴奏，24 首示范曲。\n小故事 1 收到的这台电子琴有两个白键翘起来，按照 B 站上的教程，拧了十几个螺丝放回去，又拧了十几个螺丝装好，还有两个拧不回去了，而且手都快拧成麻花了，肯定很香。\n2 看了电子琴架拼装示范图半天，都不知道怎么装电子琴架，毕竟我连劳动课上简单的小东西看说明书也做不出来。最后我对着孔的间距装好了，然后我发现电子琴可以直接放桌子上，把椅子升高一下就能弹了\u0026hellip;\n图片 评测 这些仅是我个人的看法，我不是专业的。\n优点：\n耳机看上去很高级，因为没有其他耳机，无法比较 修起来方便 有麦克风，改天我可以去做主播了（试了一下，插在电脑上没什么用） 缺点：\n音色听上去一般般 没有 MIDI 接口 没有触感检测，也就是弹出来的音没有轻重 示范曲听起来明显是一个人写的 ","date":"2024-08-05T21:23:30+08:00","permalink":"https://mumulhl.eu.org/p/new-electronic-keyboard/","title":"上手美科2089电子琴"},{"content":"dig 是用来查询 DNS 的工具，doggo 则是它现代的增强品。\n有个叫作 dog 的 dig 替代品，但是已经多年没更新了，doggo 的灵感就是来自 dog。写这篇文章时，doggo 依然保持更新。\ndoggo 不仅是一个命令行工具，还有个网页版。\n特点 采用彩色编码和表格格式的人类可读输出 支持 JSON 输出，便于脚本编写和解析 多种传输协议： DoH、DoT、DoQ、TCP、UDP、DNSCrypt 支持 ndots 和 search 配置 支持多个解析器，可自定义查询策略 支持 IPv4 和 IPv6 提供网络接口 提供 zsh 和 fish 的补全 反向 DNS 查询 灵活的查询选项，包括各种 DNS 标志 用于故障排除的调试模式 响应时间测量 支持跨平台 安装 脚本 1 curl -sS https://raw.githubusercontent.com/mr-karan/doggo/main/install.sh | sh 包管理 Homebrew: brew install doggo Arch Linux: yay -S doggo-bin Scoop (Windows): scoop install doggo Eget: eget mr-karan/doggo 二进制文件 https://github.com/mr-karan/doggo/releases\nGo Install 1 go install github.com/mr-karan/doggo/cmd/doggo@latest 快速上手 不想打五个字的话，可以 alias dig=\u0026quot;doggo\u0026quot;，把 dig 设置为 doggo 的别名，这样就只用打三个字了。\n1 2 3 4 5 doggo example.com # 查询 A 记录 doggo example.com AAAA # 查询 AAAA 记录 doggo example.com A NS # 查询多个记录 输出结果非常简洁，而且带有颜色。\n结语 文本所介绍的内容已经可以满足大部分需求了，想要更深入使用，可以观光下文档 https://doggo.mrkaran.dev/docs/。\n","date":"2024-08-04T15:36:46+08:00","permalink":"https://mumulhl.eu.org/p/doggo-tutorial/","title":"dig 的现代替代品 doggo"},{"content":"Duckduckgo AI Chat 提供了免费的 gpt-4o-mini，我开发了一个小库 duckduckgo-ai-chat 用来调用 Duckduckgo AI Chat 的 API。\n注意事项 Duckduckgo AI Chat 是有针对 IP 的额度限制的，不要滥用。\n小故事 在 jsr.io 上的 duckduckgo-ai-chat 之所以第一个版本是 2.0.0，是因为 1.0.0 基于 Bun 编写发布在 npm 上，发完才发现 bun 不符合我的 all-in-one 需求，所以就换 Deno 了\u0026hellip;\n顺便发到了 Deno 团队新搞的 jsr.io 上，不仅支持用不同包管理器安装，而且还支持在任何运行时上跑。\n兼容性 除了 Bun，其他运行时都没问题。\n安装 1 2 3 4 5 6 7 npx jsr add @mumulhl/duckduckgo-ai-chat # or pnpm dlx jsr add @mumulhl/duckduckgo-ai-chat # or yarn dlx jsr add @mumulhl/duckduckgo-ai-chat # or deno add @mumulhl/duckduckgo-ai-chat 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { initChat } from \u0026#34;@mumulhl/duckduckgo-ai-chat\u0026#34;; // 初始化，可选模型有 gpt-4o-mini, claude-3-haiku-20240307, meta-llama/Llama-3-70b-chat-hf, mistralai/Mixtral-8x7B-Instruct-v0.1 const chat = await initChat(\u0026#34;gpt-4o-mini\u0026#34;); // 一次性获取完整的回复 let message = await chat.fetchFull(\u0026#34;Hello\u0026#34;); console.log(message) // 重新回复 chat.redo() message = await chat.fetchFull(\u0026#34;Hello\u0026#34;); console.log(message) // 获取流式回复 const stream = chat.fetchStream(\u0026#34;Hello\u0026#34;); for await (let data of stream) { console.log(data) } ","date":"2024-08-01T16:12:35+08:00","permalink":"https://mumulhl.eu.org/p/duckduckgo-ai-chat-api/","title":"JavaScript/TypeScript 免费调用 gpt-4o-mini"},{"content":"Simple Friend Circle 是我偶然想到的一个超简单的友链朋友圈，它不需要后端，只需要 CI 去定时拉取博文，然后生成静态页面，再在自己的博客上用 \u0026lt;iframe\u0026gt; 引入这个静态页面。\n搭建 Fork 这个项目，在 Actions 中开启 workflows，然后开启叫作 Friend Circle 的 workflow，关闭叫作 Lint Commit Messages 的 workflow，之后在 Settings 的 Pages 中将 Branch 选为 gh-pages。\n（是不是很简单？:)）\n配置 links 文件用于配置各个博客的 RSS 链接和头像，像这样：\n1 https://mumulhl.eu.org/index.xml https://mumulhl.eu.org/img/avatar_hub440208ea63c4061633255bf6046ed7b_104338_300x0_resize_q75_h2_box_2.webp 插入博客 在想要插入友链朋友圈的网页加入这段 HTML：\n1 \u0026lt;iframe src=\u0026#34;https://YOUR GITHUB NAME.github.io/simple-friend-circle/\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;600rem\u0026#34; style=\u0026#34;border:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 样式 像颜色之类的可以到 public/main.css 自行调整，默认的颜色来自我用的 Stack 主题。\n","date":"2024-07-30T11:41:16+08:00","permalink":"https://mumulhl.eu.org/p/simple-friend-circle-tutorial/","title":"简易友链朋友圈搭建教程"},{"content":"yt-music-archive 是我写的一个小脚本，用于将 Youtube Music 上的音乐下载到本地，并将其 ID 存入一个存档文件中，也可以从存档文件中还原出音乐。\n（我在花了几个小时写完后，才想起用 yt-dlp 下载播放列表也可以做到同样的功能，算了，写了都写了，就水写篇教程吧\u0026hellip;）\n安装 1 2 3 git clone https://github.com/mumu-lhl/yt-music-archive cd yt-music-archive sudo make 或者从 AUR 安装：\n1 2 3 yay -S yt-music-archive # or paru -S yt-music-archive 使用 1 2 3 4 5 6 yt-music-archive save \u0026lt;ID\u0026gt; # 下载音乐并将 ID 存入存档文件，默认音乐保存在 ~/Music yt-music-archive save \u0026lt;ID\u0026gt; -p \u0026lt;PATH\u0026gt; # 指定音乐保存到哪个路径下 yt-music-archive fetch # 根据存档的 ID 拉取音乐，默认音乐保存在 ~/Music yt-music-archive fetch -p \u0026lt;PATH\u0026gt; # 指定音乐保存到哪个路径下 配置 目前可配置的选项不多，可以编辑 /etc/yt-music-archive/yt-music-archive.conf 或 ~/.config/yt-music-archive/yt-music-archive.conf：\n1 2 3 archive_file=~/.local/share/yt-music-archive/archive # 存储 id 的存档文件 #default_path=~/Music # 默认保存音乐的路径 结语 I\u0026rsquo;m a 🤡.\n","date":"2024-07-27T22:02:28+08:00","permalink":"https://mumulhl.eu.org/p/yt-music-archive-tutorial/","title":"存档 Youtube Music ID 批量下载音乐"},{"content":"概念 PKGBUILD PKGBUILD 文件采用 Bash 语法，用于 Archlinux 及其衍生发行版构建软件包，用户可以将自己编写的 PKGBUILD 发布到 AUR(Arch User Repository)，让其他用户构建并安装软件包（通常由工具完成，如 yay、paru）。\n编写 PKGBUILD 只需要 Bash 的 创建变量、读取变量、声明函数、创建数组 等少量知识即可，可以到 网道 WangDoc 学习。\nmakepkg 读取 PKGBUILD 构建软件包的工具。\n辅助工具 这些工具在后文会介绍具体，请先用 pacman 安装，可以简化 PKGBUILD 的维护：\ndevtools - 包含的 pkgctl nvchecker - 为 pkgctl 提供版本检测 namcap - 检测 PKGBUILD 常见的错误 updpkgsums - 自动下载软件来源，计算 hash 填入 PKGBUILD（不用另外安装） 1 sudo pacman -S devtools nvchecker namcap 这些工具你可能需要（不要的话关系也不大），使用自行看其文档：\ntermux-language-server - 为 PKGBUILD 提供语言服务器（Language Server） 基本格式 你可以在 /usr/share/pacman 目录下找到三个没有注释的 PKGBUILD 示例文件，其中 PKGBUILD.pro 应该是最有用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # https://wiki.archlinux.org/title/Arch_package_guidelines # Maintainer: Your Name \u0026lt;youremail@domain.com\u0026gt; pkgname=NAME # 名称 pkgver=VERSION # 版本 pkgrel=1 # 通常为 1，不需要更改，当版本不变需要让用户重新安装软件包时 #（如 PKGBUILD 增加补丁、修复 bug），需要加 1。 pkgdesc=\u0026#34;\u0026#34; # 介绍 arch=() # 适用的架构，如 x86_64、aarch64、i386，也可以是 any，表示软件不受架构限制 url=\u0026#34;\u0026#34; # 软件主页链接 license=(\u0026#34;GPL\u0026#34;) # 许可证 groups=() # 归属的软件包组，基本用不到 depends=() # 软件运行所需的依赖 makedepends=() # 构建软件所需的依赖 optdepends=(\u0026#34;package_name: description\u0026#34;) # 软件运行可选的依赖 provides=() # 提供的功能 conflicts=() # 与什么功能冲突，通常与 provides 的值相同 replaces=() # 该包安装时替换什么包，基本用不到 backup=() # 该包安装或卸载时，要备份的文件的路径， # 使用相对路径（如 etc/pacman.conf），通常是配置文件。 # 小知识： # 升级时包自带的要备份的文件将会以 .pacnew 后缀保存，不覆盖本地的； # 卸载时本地的要备份的文件会以 .pacsave 后缀重新命名 options=() # makepkg 选项，具体参数在 # https://man.archlinux.org/man/PKGBUILD.5#OPTIONS_AND_DIRECTIVES changelog= # 软件更新日志，基本都不写的 source=(FILENAME::URL) # 不定构架，软件来源（可以是压缩文件，也可以是 git 仓库地址，写法见下面的 git 示例）， # FILENAME 用于将下载到的文件命名为它， # 可以用上面定义的变量组成，如 $pkgname-$pkgver.tar.gz # makepkg 会自动解压，解压后的目录存于变量 srcdir # URL 则是指向文件的链接 #source=(URL) # FILENAME 也可以省略 #source_x86_64 # 相应架构的软件来源 noextract=() # 需要其他解压工具时，不解压的软件来源，填写这一项需要在 prepare 函数中解压文件 # 还要在 makedepends 填写解压工具 sha256sums=() # 不定架构的软件来源的 hash，下文将介绍用 updpkgsums 自动填写，也可以用其他的 hash，如 sha512 #sha256sums_x86_64 # 特定架构的软件来源的 hash # pkgver 函数用于获取软件版本，替代 pkgver 变量，通常用于打包直接用 git 拉取仓库进行构建的软件包 #pkgver() {} # prepare 函数准备软件构建，在 build 函数前执行 #prepare() {} # build 函数构建软件，在 package 函数前执行 #build() {} # package 函数安装软件 package() { # 安装二进制文件 # 工作步骤： # 1. 将一个文件复制到另一个文件 # 2. 赋予复制后的文件可执行权限 install -Dm755 ${srcdir}/binary ${pkgdir}/usr/bin/binary # srcdir 变量是软件来源解压后的目录 # pkgdir 变量是一个存放被打包的文件的目录 } 自动填写 hash 1 updpkgsums 示例 请根据自己要打包的软件选择示例，也可以直接跳到 如何发布。\n二进制 见 基本格式\ngit 从仓库拉取构建 只写出一些与打包二进制的不同的地方。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 pkgname=NAME-git # 名称应该以 -git 结尾 pkgver=1 # 先随便填个版本进去，等下构建时 makepkg 会自动填写 pkgver 函数生成的版本 sha256sums=(\u0026#34;SKIP\u0026#34;) # 因为拉取最新的仓库所以无法指定 hash，直接跳过检查 hash source=(\u0026#34;git+https://URL\u0026#34;) pkgver { # 从 git 仓库生成软件版本 # 其他实现见: https://wiki.archlinux.org/title/VCS_package_guidelines#Git cd \u0026#34;$pkgname\u0026#34; ( set -o pipefail git describe --long --abbrev=7 2\u0026gt;/dev/null | sed \u0026#39;s/\\([^-]*-g\\)/r\\1/;s/-/./g\u0026#39; || printf \u0026#34;r%s.%s\u0026#34; \u0026#34;$(git rev-list --count HEAD)\u0026#34; \u0026#34;$(git rev-parse --short=7 HEAD)\u0026#34; ) } 其他 如 pip、npm、cargo 等编程语言的软件包的打包是不需要手写 PKGBUILD 的，用脚本生成就可以了，见 Arch Wiki。\n测试 构建 写完 PKGBUILD 最好测试一下能否正常构建软件。\n1 makepkg 这是最简单的测试方法，但有个问题，因为安装了很多包，系统是不“干净”的，如果 PKGBUILD 中有依赖没写上去，也会正常构建，为了避免这种情况，可以用 pkgctl 构建。\n1 pkgctl build pkgctl 会自动在一个“干净”的 chroot 里下载安装依赖并构建软件。而且还会生成 .SRCINFO 文件，这是发布至 AUR 必须要有的文件。\n安装 1 makepkg --install 发布 如果测试没问题的话就可以发布了。首先的首先，你需要一个 AUR 账号，这个步骤很简单，就不写了。\n验证 创建 AUR 专用的 SSH 密钥。\n1 ssh-keygen -f ~/.ssh/aur 在 ~/.ssh/config 中加入这些内容：\n1 2 3 Host aur.archlinux.org IdentityFile ~/.ssh/aur User aur 最后在 AUR 账号的设置页面加入 ~/.ssh/aur.pub 里的公钥就好了。\n生成 .SRCINFO 文件 如果不是用 pkgctl 测试构建软件包，那么需要这条命令生成 .SRCINFO 文件：\n1 makepkg --printsrcinfo \u0026gt; .SRCINFO 创建包仓库 AUR 只接受 master 分支的推送。\n1 2 3 4 5 6 7 # 如果还没有 git 仓库 git -c init.defaultbranch=master clone ssh://aur@aur.archlinux.org/pkgbase.git # 如果已有 git 仓库 git switch -c master ## 如果有了提交 git branch -d 推送 这一步不用我多说吧 :)\n自动更新 根据 PKGBUILD 生成自动更新的配置 .nvchecker.toml：\n1 pkgctl version setup 更新 PKGBUILD 中的 pkgver：\n1 pkgctl version upgrade 再用 updpkgsums 自动填写 hash，非常的完美！\n日常维护 当你维护一大堆包的时候，显然一个个去更新太慢了。可以把所有包的仓库放在一个目录下，再在这个目录下执行这条命令一次性更新所有包：\n1 pkgctl version $(ls) 如果哪个包被更新了，要手动去构建一下，然后提交推送，避免出问题。这个任务不算很难，毕竟一下子也不会有很多包更新。\n结语 这篇文章写起来超费时间，比写三篇小短文的总时间还要多 :(\n因为找不到 PKGBUILD 编写、发布、自动更新一体化的教程，所以就自己写啰。\n这篇文章介绍编写的 PKGBUILD 比较简单，不是很完整，剩下就是下一篇文章的事了 :)\n","date":"2024-07-25T19:54:02+08:00","permalink":"https://mumulhl.eu.org/p/pkgbuild-tutorial/","title":"PKGBUILD 编写、发布、自动更新教程"},{"content":"本站所用的主题没有直接把 RSS 链接显示在网页上，而是放在了 HTML \u0026lt;link\u0026gt; 标签里，但是要怎么订阅本站的所有或部分文章呢？\nHowTo 如果要订阅本站所有文章，在 RSS 阅读器里直接订阅 https://mumulhl.eu.org。如果要根据标签、分类订阅，直接订阅相应的链接就可以了，如 https://mumulhl.eu.org/categories/skill/。\n（RSS 还能这样订阅以前都不知道，最近才意外知道）\n如何实现？ HTML \u0026lt;link\u0026gt; 最常见的用法就是为网页引入 CSS 文件，它的作用是标志网页和外部资源的关系。\n1 \u0026lt;link href=\u0026#34;main.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; href 属性的值是文件路径，rel 则是 relationship 的缩写，表示网页和外部资源的关系。rel 是 stylesheet，就表示 main.css 是该网页的 CSS。\n引入 RSS 的 \u0026lt;link\u0026gt; 是长这样的：\n1 \u0026lt;link href=\u0026#34;index.xml\u0026#34; rel=\u0026#34;alternate\u0026#34; type=\u0026#34;application/rss+xml\u0026#34;\u0026gt; type 的值为 application/rss+xml 标志了 index.xml 的类型是 RSS，rel 的值为 alternate 根据 MDN 意思是当前网页的替代。\nRSS 阅读器通常支持这种方式订阅，以前我只知道输入 RSS 文件的链接订阅\u0026hellip;\n","date":"2024-07-23T09:57:30+08:00","permalink":"https://mumulhl.eu.org/p/rss-for-my-website/","title":"用 RSS 订阅本站的所有文章或按标签、分类订阅文章"},{"content":"以后也会写像这样的工具类文章，写得特快\u0026hellip;不会写得很啰唆，简单利落。\nVermin Vermin 是一个检测 Python 代码所需的最低版本的工具，在本文写时已经有一段时间没有更新了。\n安装 1 2 3 4 5 6 7 8 9 10 # pip pip install vermin # pipx pipx install vermin # AUR yay -S python-vermin # or paru -S python-vermin 使用 1 2 # 检测目录下的所有 Python 代码，这条命令可以满足大部分需求，不需要怎样配置 vermin . ","date":"2024-07-22T14:56:53+08:00","permalink":"https://mumulhl.eu.org/p/detect-minimum-python-version/","title":"检测 Python 代码所需的最低版本"},{"content":"上次写博客还是在上次呸，上次写博客在一年前了\u0026hellip;\n概念 Scrobbler Scrobbler 的意思是是向音乐社区平台提交音乐播放记录的程序。\n音乐社区平台 音乐社区平台，往往不直接提供音乐，允许用户评论音乐，记录 Scrobbler 向其提交的 不同音乐播放器 上音乐播放记录，根据记录的数据推荐音乐， 总结听歌报告。\n选择音乐社区平台 Last.fm 是一个音乐社区平台用户量应该是最多的，部分功能收费。\nListenBrainz 是我目前正在使用的音乐社区平台，是开源项目，可以自行部署，完全免费。\n为了节省打字时间，还有一些可以自行部署的音乐社区平台就自行去找啦~\n选择 Scrobbler 搜一下一大把的。\nPano Scrobbler 是自由软件，支持多种音乐社区平台，界面采用 Material You。鉴于我只在 Android 上听歌，所以只能推荐在 Android 上的 Scrobbler 了。\n下一步 搞好音乐社区平台和 Scrobbler，然后正常听音乐就可以了。\n","date":"2024-07-21T21:57:29+08:00","permalink":"https://mumulhl.eu.org/p/music-track-tutorial/","title":"追踪音乐播放记录"},{"content":"这是新博客的第一篇文章， 是对过去一年的总结。\n这篇文章的缘由 各位看官可能感到奇怪， 对过去一年的总结应该写在年初或者年末才对啊， 这篇怎么写在年中呢？\n去年年初时我写过一篇《年记》， 里边承诺今年按时再写一篇《年记》， 好巧不巧的是， 我把生成博客的文件夹删了， 以至于我无法发那篇文章。 实际上这些都是借口， 博客可以花时间在搞， 但是那篇文章我写都没写。 年初过去了， 接下来要等年末发， 但是我是在有些等不及了， 于是选择现在发这篇文章。\n好， 接下来正式开始回忆过去一年。\n使用的软件 操作系统 刚好一年前， 我装了 Arch Linux， 这时还是双系统， 我保留了 Windows。 前几天我用 Manjaro Linux 替代了 Windows 的位置， 装 Manjaro Linux 的原因是 Arch Linux 出了点问题， 启动速度很慢， 但找不到问题在哪， 想去重装， 不过 Arch Linux 装起来了有点麻烦， 有些东西还得自己手动配置， 于是我选择了 Manjaro Linux。 Manjaro Linux 装起来就是简单， 鼠标点几下就装好了。\n桌面环境 换成 Arch Linux 后就有了桌面环境一说。 最开始按照看的教程安装了 KDE， 用起来还行。\n直到今天一月份， 我感觉 KDE 有许多功能我都用不上， 于是想要去找一个非常简单的桌面环境， 在看 B 站的时候看到了 Hyprland， 我就去找了个配置去用。 Hyprland 需要自己去装很多需要的软件， 例如通知、 软件启动器等等， 给用户极大的自定义空间。\n之后我用上了 EAF， 我给 EAF 提交了很多优化 Hyprland 上的体验的补丁， 但是还不能用得顺手， 于是我换用了 Gnome， 现在我使用的桌面环境就是它。 在 Gnome 上， EAF 用得顺手多了。\n编辑器 我试过不少的编辑器， 比如 VSCodium、 Neovim、 Emacs 等等， 最终使用了 Emacs + Helix， Emacs 是主力， Helix 很少用， 只在终端下使用。\n选择 Emacs 也有个来由， 我觉得编码的时候， 把手在键盘和鼠标之间换来换去， 严重干扰了编码时的思维， 所以我尝试取用全键盘的编辑器。\n最开始用的是 VSCodeium 配上 Neovim 插件， 但是一装好就感觉极大的不适应（原因记不清了， 随便编一个 ）， 故此放弃。\n之后我又尝试了 Neovim， 我抄配置抄得很厉害， 整个配置几百行代码， 没几行出自自己之手。\n后来我看了陈斌大佬的一年成为 Emacs 高手 (像神一样使用编辑器)后， 了解 Emacs 的一些优势， 决心去用用 Emacs， 开始去安装不同大佬的配置来用， 最终尝试失败， 换回了 Neovim。 今年年初不知咋的， 我又想去试试 Emacs， 这次我不去抄配置了， 开始自己动手去写， 这次成功用上了 Emacs， 现在用着很顺手， 想抛弃都做不到。 现在我用的配置是经过多次大规模改写后的， 最开始用 straight + use-package 管理插件， 在参考了懒猫大佬的配置后， 改用了 submodule 管理插件。\n我现在的配置用 lsp-bridge 作为补全插件， 最初我是在看 B 站的时候， 看到了一个关于 lsp-bridge 的视频， 想着试一试没想到上了瘾， 又用上了 EAF、 blink-search、 popweb 等插件， 懒猫大佬开发的插件实在是太好用了， 真是爱不释手， 平时大部分操作依赖他开发的插件。\n开源贡献 在过去一年（2022）我可以肯定的说， 我没有贡献任何代码， 但我从今年（2023）的一月份在 GitHub 上开始开源贡献。 最初我是在用 lsp-bridge 的时候发了一个 =fix typo= 的 PR， 自此开启了每周开源贡献之旅。\n我发的 PR 都是对软件的改进， 例如修复 bug、 拓展功能等等， 这既方便了我的使用， 也方便了其他人的使用。 虽然有些 PR 我已经不用了， 但我仍觉得它依旧有价值。\n开源贡献加强了我的能力， 尤其是代码阅读能力， 最开始给 EAF 添加 Hyprland 的支持时， 代码读起来很不顺， 现在看一个陌生项目， 读得很快。\n开源贡献中有着许多大佬的帮助， 让我知道了代码该怎样写可读性高， 维护成本低。 我主要发 PR 给懒猫大佬的项目， 他对我的 PR 处理很仔细， review 有时处理起来比较麻烦， 但是让我也学到了一些东西。 懒猫大佬还有其他的大佬对我的代码进行过改良， 我都看了那些改进的 commit， 学到了不少。\n我开发了 EAF PyQterminal， 这是一个基于 EAF 开发的终端模拟器， 我原本想要自己去宣传宣传， 但是懒猫大佬抢先我一步， 不仅在 Emacs China 论坛上发了， 还在他的推特上发了， 懒猫大佬人是真的好！ 这个软件开发出来还是有许多问题的， 懒猫大佬不断给我提 issue、 PR， 处理起来要费一点时间， 但是真的好开心， 以前的项目都是无人问津（已经被我删了）， 现在有人来关注我的项目， 多好啊。 这些 issue 和 PR 使得它更加完善， 感谢懒猫大佬！！！\n新博客 新博客与原来的旧博客不同， 换用 Hugo 作为静态网站生成器， 如果以后文章多了， 速度不会像 Hexo 那样慢， 现在还不知道以后文章会不会多起来。\n新博客采用 Hugo BearBlog 作为主题， 我很喜欢这种极简风格的主题， 以前用的主题现在看来有些花哨。\n","date":"2023-06-30T20:17:32+08:00","permalink":"https://mumulhl.eu.org/p/first-post/","title":"过去一年"}]